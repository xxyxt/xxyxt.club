<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>下雪不下雨的个人博客</title>
  
  <subtitle>to be a learner</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xxyxt.github.io/"/>
  <updated>2019-05-25T12:54:21.278Z</updated>
  <id>https://xxyxt.github.io/</id>
  
  <author>
    <name>xxyxt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL常用操作1</title>
    <link href="https://xxyxt.github.io/2019/05/25/SQL%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C2/"/>
    <id>https://xxyxt.github.io/2019/05/25/SQL常用操作2/</id>
    <published>2019-05-25T12:54:21.199Z</published>
    <updated>2019-05-25T12:54:21.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><ul><li><p>解决的问题：持久化存储 优化读写 保证数据的有效性</p></li><li><p>关系型数据库：基于E-R模型 使用sql语言进行操作</p></li><li><p>分类：文档型 服务型</p></li><li><p>数据库设计</p><p>  1.三范式：列不可拆分 唯一标识 引用主键<br>  2.关系及存储：1对1 1对多 多对多</p></li></ul><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li>as 给表取别名</li></ul><p>语法：select * from table_name as tn; as可以省略</p><ul><li><p>完成列筛选<br>语法：select table_name,column</p></li><li><p>查询前n部分的数据</p></li></ul><p>top n column:表示查看前n行<br>top n percent column:表示查看前百分之几的数据</p><ul><li>排序：order by column</li></ul><p>eg: select top 2 * from table_name order by column asc/desc,column2 desc 多个条件的排序</p><ul><li>消除重复：distinct</li></ul><p>eg: select distinct column from table_name</p><ul><li>条件查询：写在where后面</li></ul><p>between…and 表示一个连续范围内<br>in 表示在一个非连续范围内</p><ul><li>模糊查询</li></ul><p>用于处理字符串类型的值，运算符包括：like % _ [] ^<br>%与<em>写在[]中表示本身的含义<br>在[]表示一个连续范围内可以使用</em><br>^写在[]内部的开头语，表示不适用内部的任意字符</p><ul><li>连接查询</li></ul><p>当需要的结果从多张表中取时<br>内连接：inner join 两表中完全匹配的数据<br>左外连接：left outer join 两表中完全匹配的数据 左表中特有的数据<br>右外连接：right outer join 两表中完全匹配的数据 右表中特有的数据<br>完全外连接：full outer join</p><p>语法：select * from table_name1 inner join table_name2 on table_name1.cid=table_name2.cid</p><ul><li>聚合函数</li></ul><p>对数据进行合并<br>count: select COUNT(*) as count1 from table_name<br>NULL不做计数</p><p>max(min)：select max(scorevalue) from table_name<br>avg：select avg(secorevalue) from subjectinfo inner join scoreinfo on subid=subject.sid where sTitle=’语文’</p><ul><li>开窗函数 over()</li></ul><p>和聚合函数一起使用，将统计信息分布到每一行中去</p><ul><li><p>分组 group by 列名1 列名2 </p></li><li><p>联合查询：列数要一致，列的类型要一样</p></li></ul><p>union/union all/ except/ intersect<br>在查询结果出显示汇总</p><ul><li>快速备份</li></ul><p>向未有表备份：select 列名 into 备份表名 from 源表名<br>向已有表备份：insert into table_name(column1) select column1 fron table_name2</p><ul><li>总结<br>select distinct top n * from t1 join t2 on…where group by…having…order by</li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ul><li>类型转换函数<br>cast(expression as date_type): 将任意类型转换到任意类型<br>convert(date_type,expression[style]) 将任意类型转换到任意类型,如果目标类型是字符串，则可以设置格式</li><li>字符串函数<br>ascii,left,right.substring:字符串截取<br>len,lower,upper,ltrim,rtrim:转大小写 去空格</li><li>日期函数<br>getDate,dateAdd,dateDiff,datePart</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库简介&quot;&gt;&lt;a href=&quot;#数据库简介&quot; class=&quot;headerlink&quot; title=&quot;数据库简介&quot;&gt;&lt;/a&gt;数据库简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;解决的问题：持久化存储 优化读写 保证数据的有效性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关系型数据库
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://xxyxt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>入坑之路</title>
    <link href="https://xxyxt.github.io/2019/05/25/%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%B7%AF/"/>
    <id>https://xxyxt.github.io/2019/05/25/面试之路/</id>
    <published>2019-05-25T12:45:44.333Z</published>
    <updated>2019-05-25T13:15:52.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自学历程"><a href="#自学历程" class="headerlink" title="自学历程"></a>自学历程</h2><p>从18年9月份开始接触到python，看完了黑马程序的python基础教学视频和一些相关的基础书籍之后，转而开始学C语言。</p><p>过了一遍谭浩强的C语言教材之后，开始在牛客网刷算法题。时间转眼来到了11月份，考虑到自己是非科班，平时也没有相关的项目经历，面试的时候没有拿的出手的经历，于是报名了18年12月份的PAT甲级的考试。</p><p>从报完名到考试只剩一个月的时间，期间入手了一本《算法笔记》，这本书对于我这样的小白来说还是很不错的，书中涵盖了数据结构和一些基础算法知识。这一个月的时间都是在看书和刷题中度过的，期间也学会了用C++来刷题但是只限于STL库，关于C++的面向对象的知识没有学习过，因为C++自带的STL库对刷题来说，还是很方便的。</p><p>考完PAT之后，结束了之前一个月的紧张备考状态，刷题也刷了累了，于是开始学习JAVA了，毕竟了解了各大公司对JAVA的需求还是最大的。有过Python的面向对象的基础的和C语言基础，JAVA的学习过程的轻松多了，走马观花的看完了java的基础书籍《第一行代码》，也算是对JAVA有了一个初步的认知。</p><h2 id="面试历程"><a href="#面试历程" class="headerlink" title="面试历程"></a>面试历程</h2><p>互联网的实习开始的时间都比较早，过完元宵节，2月末来到学校之后，bat的一些暑期实习提前批已经开始启动了。通过内推投了阿里和腾讯。内推反应还是挺快的，投完马上就安排面试了，阿里电面感觉问题都回答出来了，不知道为什么就挂了。其实阿里的电话面试感觉问的东西还是比较基础的，<strong>指针数组和数组指针的区别</strong>、<strong>C++的内存内存管理</strong>之类的。不知道是不是因为我不是科班的原因，所以问的比较浅。关于语言的话，可以选C++或者JAVA，我选的C++。基础问题结束之后就是手撕代码了，具体的题目不太记得了，题目都感觉挺简单的，比平时刷的题目要简单。当时只是写了大致思路，关于细节部分没有过多思考，因为怕耽误太长时间。所以现在想想可能是因为没有注重细节，所以可能才挂的。</p><p>腾讯前后一共电面了三次，每次面挂都会有人把简历捞起来。第一次是视频面试的，自我介绍完之后就直接撕代码。<strong>寻找二叉树两个节点的最近公共父节点</strong>，当时思考了10分钟没啥思路，感觉很复杂，平时关于二叉树的题目练习的比较少。然后就直接跟面试官说没啥思路，想着快点做下一题，天真的我还以为还会有下一题，谁想到直接就问我有啥想问了没……就这样凉了……心塞。后面又陆续被腾讯的其他部门捞起来面试，有一个听了自我介绍之后就直接说不合适。还有一个问了一些<strong>常用排序算法的复杂度</strong>，<strong>C++的深拷贝和浅拷贝</strong>，这些问题都不会，直接凉凉。</p><p>阿里和腾讯的提前批的面试虽然都失败了，但是也知道了自己的不足之处。后来又投了拼多多的提前批，通过了笔试之后，3月23号现场面试。有了之前的经历，特意把C++面向对象的一些知识恶补了一下。技术面问的问题我之前都在网上看过，有所准备，感觉回答的还可以，以为会通过，没想到还是凉了。后来又投了拼多多的正式批，同样是通过笔试没过面试，面试的时候手撕代码通过了，又问了<strong>设计模式</strong>，没回答出来，可能因为这个挂的吧。</p><p>这段时间打击挺大的，越找心里越没谱，感觉自己学的太水了，项目经历又为零，没有实际的开发经验，担心自己找不到实习。没办法，既然选择了，那就只有坚持，针对面试出现的问题，继续各种找视频看书刷题。</p><p>后来又投了字节跳动，网易、蘑菇街等各大互联网公司，网易蘑菇街直接表刷，字节跳动笔试没过，各种凉，凉到怀疑人生。</p><p>5月份到了，各大互联网公司的实习招聘都基本结束了，自己可能凉了，去互联网的计划可能要破灭了。直到接到了恒生的笔试和宣讲会通知，了解了恒生的业务是互联网金融，公司规模也挺大的，于是就趁着宣讲会开始的前几天补了一下关于数据库的知识，跟金融相关的，肯定离不开数据库，果不其然，笔试的时候考了一些基础的增删改查相关的sql语句。顺利通过了笔试之后便是面试了，恒生的面试形式第一次见，2个面试官，一次进去一组一起面，我那组有六个人，每个人轮着自我介绍，介绍完轮着讲自己的项目，跟我一组的都有项目经历，就我没有。最后面试官问了一个统一的问题，为什么要来恒生，吹完一波之后，然后就到了提问环节。整个面试持续了2个小时。两天后收到了offer，超级开心，现在想想，可能是因为准备的比较充分，还有可能是因为跟我一组的都不会数据库，就我会数据库吧，临时抱佛脚，学了三天的数据库居然这么给力，帮我拿到了第一份暑期实习offer。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从18年9月份开始自学，到5月份拿到第一份offer，一路走来，感觉自己走了不少弯路。首先学的东西都只是停留在表面，其实关于语言，只要能够学通一门C++或者JAVA就可以了，真的没必要贪多。其次就是没有必要一直刷题，适量就可以了，还是应该把更多的时间放在学习关于开发的框架和一些实际应用层面的东西上面。还好最后拿到了offer，但是学习之路才刚刚开始，之前所有的学习都是为了工作所做的准备。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自学历程&quot;&gt;&lt;a href=&quot;#自学历程&quot; class=&quot;headerlink&quot; title=&quot;自学历程&quot;&gt;&lt;/a&gt;自学历程&lt;/h2&gt;&lt;p&gt;从18年9月份开始接触到python，看完了黑马程序的python基础教学视频和一些相关的基础书籍之后，转而开始学C语言。&lt;
      
    
    </summary>
    
      <category term="面试" scheme="https://xxyxt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="实习" scheme="https://xxyxt.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SQL常用操作2</title>
    <link href="https://xxyxt.github.io/2019/05/09/SQL%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://xxyxt.github.io/2019/05/09/SQL常用操作/</id>
    <published>2019-05-09T06:30:53.899Z</published>
    <updated>2019-05-25T13:04:48.500Z</updated>
    
    <content type="html"><![CDATA[<p>关于SQL的常见操作主要就是增删改查</p><h3 id="增，就是增加数据。该语句用于向表中插入新纪录。insert-into有两种用法。"><a href="#增，就是增加数据。该语句用于向表中插入新纪录。insert-into有两种用法。" class="headerlink" title="增，就是增加数据。该语句用于向表中插入新纪录。insert into有两种用法。"></a>增，就是增加数据。该语句用于向表中插入新纪录。insert into有两种用法。</h3><ul><li>无需指定要插入数据的列名，只提供被插入的值</li></ul><p>语法：insert into table_name values(value1,value2…)<br>但是这种方法要注意一点，那就是需要列出插入行中的每一列数据，如果某一列没有数据的话，可以使用<strong>引号</strong>替代，如果没有列出插入行中每一列数据，就会报错。</p><ul><li>指定列名及被插入的值</li></ul><p>语法：insert into table_name(column1,column2…) values(value1,value2)<br>通过这种方法也可以向指定的列中添加数据</p><ul><li>一次性向表中插入多条数据</li></ul><p>语法：insert into table_name values(value1,value2…)(value3,value4…)。可以指定列名，也可以不指定列名，如果指定了列名，则是向指定列添加数据。如果不指定列名，那么则需要列出插入行中的每一列数据。</p><h3 id="删，也就是删除数据，这里其实也有两种，delete与drop。然而这两种的效果确实不一样的，虽然都能删除数据。"><a href="#删，也就是删除数据，这里其实也有两种，delete与drop。然而这两种的效果确实不一样的，虽然都能删除数据。" class="headerlink" title="删，也就是删除数据，这里其实也有两种，delete与drop。然而这两种的效果确实不一样的，虽然都能删除数据。"></a>删，也就是删除数据，这里其实也有两种，delete与drop。然而这两种的效果确实不一样的，虽然都能删除数据。</h3><ul><li>delete。该语句用于删除表中的记录。但是表的结构、属性、索引等仍保持不变，也不会释放内存空间。</li></ul><p>语法：delete from table_name where some_column=some_value<br>ps:truncate table_name 清空表 数据重置<br>注意：使用delete删除数据时，如果省略了where语句，那么所有数据都会被删除。</p><ul><li>drop。该语句用于删除表，且内存空间会被释放。</li></ul><p>例如表myTable中有多条title相同的数据，要删除相同的，只保留一条，那么操作为：　　　<br>select distinct <em> into newTable from myTable;<br>delete from myTable;<br>insert myTable select </em> from newTable;<br>drop table newTable;</p><h3 id="改，也就是更改表中的数据（update-，用于更新表中已存在的数据。"><a href="#改，也就是更改表中的数据（update-，用于更新表中已存在的数据。" class="headerlink" title="改，也就是更改表中的数据（update)，用于更新表中已存在的数据。"></a>改，也就是更改表中的数据（update)，用于更新表中已存在的数据。</h3><ul><li>语法：update table_name set column1=value1,column2=value2,…where some_column=some_value;注意：使用update更新表中数据时，如果省略了where子句，那么表中所有数据都将被更新。</li></ul><h3 id="查，也就是查询表中的数据（select）。"><a href="#查，也就是查询表中的数据（select）。" class="headerlink" title="查，也就是查询表中的数据（select）。"></a>查，也就是查询表中的数据（select）。</h3><ul><li><p>语法：select column_name,column_name frome table_name;或select * from table_name;</p></li><li><p>选取表中包含某字符的数据</p></li></ul><p>例如，选取表myTable中play包含 ‘古’ 的所有数据，则操作为，select * from [dbo].[myTable] where play like ‘%古%’    </p><ul><li>选取表中以某字符开始的数据。    </li></ul><p>例如，选取表myTable中play以 “古” 开头的所有数据，则操作为，select * from [dbo].[myTable] where play like ‘古%’</p><ul><li>选取表中以某字符结尾的数据。</li></ul><p>例如，选取表myTable中play以 “古” 结尾的所有数据，则操作为，select * from [dbo].[myTable] where play like ‘%古’</p><ul><li>选取表中指定长度包含指定字符的数据。</li></ul><p>例如，选取表myTable中play包含三位且中间为 “古”的数据，则操作为 select * from [dbo].[myTable] where play like ‘_古_’</p><ul><li><p>选取表myTable中play包含三位且结尾是 “古” 的数据，则操作为 select * from [dbo].[myTable] where play like ‘__古’<br>ps：%  =&gt; 代表0个或多个字符<br>　　　　_   =&gt; 代表1个字符</p></li><li><p>使用in操作符，该操作符允许在where子句中规定多个值。</p></li></ul><p>例如，要选取表myTable中title为 “扫毒” 或 “贪狼” 的数据，则操作为 select * from [dbo].[myTable] where title in (‘扫毒’, ‘贪狼’)</p><ul><li>between操作符，选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。</li></ul><p>例如，要选取表myTable中score 介于 10 到 200 间的数据。则操作为 select * from [dbo].[myTable] where score between 10 and 200</p><ul><li>选取要返回指定数目的数据（select top）。</li></ul><p>语法：select top number|percent column_name from table_name;</p><ul><li>返回表中唯一不同的值（distinct）。</li></ul><p>语法：selcet distinct column_name,column_name from table_name</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于SQL的常见操作主要就是增删改查&lt;/p&gt;
&lt;h3 id=&quot;增，就是增加数据。该语句用于向表中插入新纪录。insert-into有两种用法。&quot;&gt;&lt;a href=&quot;#增，就是增加数据。该语句用于向表中插入新纪录。insert-into有两种用法。&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="https://xxyxt.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>拼多多20届春招编程题</title>
    <link href="https://xxyxt.github.io/2019/04/03/%E6%8B%BC%E5%A4%9A%E5%A4%9A20%E5%B1%8A%E6%98%A5%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>https://xxyxt.github.io/2019/04/03/拼多多20届春招编程题/</id>
    <published>2019-04-03T13:28:26.448Z</published>
    <updated>2019-04-03T13:45:01.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h3><p>一个偶数个数的整型数组，将数组中的元素两两配对相加，得到的值中存在最大值和最小值，请找到一种配对方法，使得得到的结果中最大值和最小值的差值最小，并输出这个最小差值。<br>第一行输入数组元素的个数N，第二行输入N个元素。2&lt;=N&lt;=10000。</p><p><strong>示例：<br>输入<br>4<br>1 2 3 6<br>输出<br>2</strong><br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> num,i,j,k;</span><br><span class="line"><span class="keyword">int</span> max_num=<span class="number">-100000000</span>;</span><br><span class="line"><span class="keyword">int</span> min_num=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> sum1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line"><span class="built_in">array</span>[i]=num;</span><br><span class="line">&#125; </span><br><span class="line">sort(<span class="built_in">array</span>,<span class="built_in">array</span>+i);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>,k=i<span class="number">-1</span>;j&lt;k;j++,k--)</span><br><span class="line">&#123;</span><br><span class="line">sum1=<span class="built_in">array</span>[j]+<span class="built_in">array</span>[k];</span><br><span class="line"><span class="keyword">if</span>(sum1&gt;max_num)</span><br><span class="line">&#123;</span><br><span class="line">max_num=sum1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum1&lt;min_num)</span><br><span class="line">&#123;</span><br><span class="line">min_num=sum1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;max_num-min_num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>100% AC</strong></p><h3 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h3><p>输入三行元素；<br>第一行元素之间用空格隔开，表示0-9数字中每个的个数的可使用次数；<br>第二行输入一个数字在0-9范围内，表示整数A的位数；<br>第三行输入一个数字在0-9范围内，表示整数B的位数；<br>整数A和整数B从第一行给定的元素中挑选数字组成相应的整数，整数允许前导多个0。<br>输出A和B的最小乘积。<br><strong>示例1：<br>输入<br>1 1 1 1 1 1 1 1 1 1<br>1<br>9<br>输出<br>0<br>示例2：<br>输入<br>1 3 1 1 1 1 1 1 1 1<br>2<br>2<br>输出<br>11</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> &amp;j,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum+=j;</span><br><span class="line">a[j]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum*<span class="number">10</span>+j;</span><br><span class="line">a[j]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num_A=<span class="number">0</span>,num_B=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum_min=<span class="number">0</span>,sum_max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_count=<span class="number">0</span>,min_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;count;</span><br><span class="line"><span class="built_in">array</span>[i]=count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num_A&gt;&gt;num_B;</span><br><span class="line">max_count=num_A&gt;num_B?num_A:num_B;</span><br><span class="line">min_count=num_A&gt;num_B?num_B:num_A;</span><br><span class="line">sum_min=creat(<span class="built_in">array</span>,j,min_count);</span><br><span class="line">sum_max=creat(<span class="built_in">array</span>,j,max_count);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum_max*sum_min&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>65% 有几组结果没有通过，应该是数据太大溢出，考虑用一下大数相乘应该可以通过，可惜没有时间写了。</strong></p><h3 id="第三题："><a href="#第三题：" class="headerlink" title="第三题："></a>第三题：</h3><p>每只袜子都一个色度，如果两只袜子的色度差值在小于或等于允许的差值d，则默认这两只袜子可以构成一双，如果大于d,则不能构成一双袜子。<br>第一行给出若干只袜子的色号，第二行给出色差的最大值，现在随机从这堆袜子中拿出两只袜子，求这两只袜子恰好构成一双的概率。<br>结构保留6位小数输出。<br><strong>示例：<br>输入<br>{1,31,18,19,25}<br>10<br>输出<br>0.400000</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strToNum</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=str.length();</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum+=str[i]-<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum=sum*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; strToNumArray(<span class="built_in">string</span> str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len=str.length();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> num=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">','</span> || i==len<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=strToNum(num);</span><br><span class="line">v.push_back(temp);</span><br><span class="line">num=<span class="string">""</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">num+=str[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> limit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count_re=<span class="number">0</span>;</span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;limit;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=strToNumArray(str);</span><br><span class="line"><span class="keyword">int</span> size=v.size();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;size;j++)</span><br><span class="line">&#123;</span><br><span class="line">re.push_back(v[j]-v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size_re=re.size();</span><br><span class="line">sort(re.begin(),re.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size_re;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(re[i]&lt;=limit)</span><br><span class="line">&#123;</span><br><span class="line">count_re++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> p=<span class="keyword">double</span>(count_re)/<span class="keyword">double</span>(size_re);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6f"</span>,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>100%AC</strong></p><h3 id="第四题："><a href="#第四题：" class="headerlink" title="第四题："></a>第四题：</h3><p>输如两个字符串word1和word2，可以进行删除，替换，添加字符操作，将word1最少经过几次操作可以变成word2。输出这个最小次数。<br>字符串长度N&lt;100。<br><strong>示例1：<br>输入<br>horse<br>ros<br>输出<br>3</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一题：&quot;&gt;&lt;a href=&quot;#第一题：&quot; class=&quot;headerlink&quot; title=&quot;第一题：&quot;&gt;&lt;/a&gt;第一题：&lt;/h3&gt;&lt;p&gt;一个偶数个数的整型数组，将数组中的元素两两配对相加，得到的值中存在最大值和最小值，请找到一种配对方法，使得得到的结果中最大值和最小值的差值最小，并输出这个最小差值。&lt;br&gt;第一行输入数组元素的个数N，第二行输入N个元素。2&amp;lt;=N&amp;lt;=10000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;br&gt;输入&lt;br&gt;4&lt;br&gt;1 2 3 6&lt;br&gt;输出&lt;br&gt;2
&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c/C++" scheme="https://xxyxt.github.io/tags/c-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL介绍</title>
    <link href="https://xxyxt.github.io/2019/04/02/STL/"/>
    <id>https://xxyxt.github.io/2019/04/02/STL/</id>
    <published>2019-04-02T03:17:19.705Z</published>
    <updated>2019-04-02T09:00:28.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li><p>定义：变长数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;; <span class="comment">//二维数组</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>元素访问</p><p>1.和数组一样通过下标索引的方式访问，索引范围[0,vi.size()-1];<br>2.通过迭代器访问,类似于指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>然后可以通过*it访问vector里面的元素。</p></li><li><p>常用函数</p><p>1.push_back(x):在vector后面添加一个元素x，时间复杂度O(1)。<br>2.pop_back():删除vector尾元素，时间复杂度O(1)。<br>3.size():获取元素个数，时间复杂度O(1)。<br>4.clear():清空所有元素，时间复杂度O(n)。<br>5.insert(it,x):在迭代器it处插入一个元素x,时间复杂度O(n)。<br>6.erase(it):删除迭代器it处的元素，时间复杂度O(n)。<br>7.erase(first,last):删除[first,last)内的所有元素，时间复杂度O(n)。参数类型为迭代器类型。</p></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>  内部自动有序且不含重复元素的容器</p><ul><li><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure></li><li><p>元素访问方式</p><p>只能通过迭代器访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>*<em>除了vector和string之外的STL容器都不支持</em>(it+i)的访问方式，因此只能按照通过的迭代器访问方式访问。</p><ul><li>常用函数</li></ul><p>1.insert(x)：将x插入容器，并自动递增排序和去重，时间复杂度O(logn)。<br>2.find(value)：找到值为value的迭代器，时间复杂度O(logn)。<br>3.erase(it)：删除单个元素，时间复杂度O(1)。<br>4.erase(value)：删除元素的值，时间复杂度O(logn)。<br>5.erase(first,last)：删除一个区间(first,last]内的所有元素，时间复杂度为O(first-last)。<br>6.size()：获取元素个数，O(1)。<br>7.clear()：清空元素。O(n)。</p><p><strong>multiset</strong>：不去重<br><strong>unordered_set</strong>：去重但是不排序</p></li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string用的比较多，关于定义和访问方式就不在赘述了，直接总结一下常用的函数和字符数组的转化方式。</p><ul><li><p>string-&gt;字符数组</p><p>str.c_str():可以将string类型转化为字符数组</p></li><li><p>字符数组-&gt;string</p><p>string(char* a):直接使用强制转换</p></li><li><p>insert(int pos,string str):在pos位置插入字符串str</p></li><li>insert(it,it2,it3)：it为原字符串待插入的位置，it2和it3为待插入字符串首尾迭代器</li><li>erase(it):删除单个元素，it为要删除元素的迭代器。</li><li>erase（first,last):删除[first,last)区间的元素。</li><li>erase(int pos,int length):pos为开始删除元素的起始位置，length为删除个数。</li><li>clear():清空，复杂度O(1)。</li><li>substr(int pos,int len):返回从pos位开始，长度为len的子串。时间复杂度O(len)。</li><li>find(string str2):当str2是str的子串时，返回str2第一次出现的位置；如果不是，则返回string::nops。</li><li>find(string str2,int pos):从pos位开始匹配。</li><li>replace(pos,len,str2):从pos位开始将长度为len的子串替换为str2。</li><li>replace(it1,it2,str2):将[it1,it2)范围内的子串替换成str2。</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1,typename2&gt; mp;</span><br></pre></td></tr></table></figure></li><li><p>访问方式</p><p>迭代器访问：it-&gt;first,it-&gt;second;</p></li><li><p>常用函数</p></li><li><p>find(key):返回键为key的迭代器，时间复杂度O(logn)。</p></li><li>erase(it):删除单个元素，it为迭代器，时间复杂度O(1)。</li><li>erase(key):删除单个元素，key为键值，时间复杂度O(logn)。</li><li>erase(first,last):删除[first,last)区间内的元素，时间复杂度O(last-first)。</li><li>size()：获取映射对数。时间复杂度O(1)。</li><li>clear()：清空。时间复杂度O(N)。</li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li>定义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure></li></ul><ul><li>元素访问<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span><span class="params">()</span></span>  <span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="title">front</span><span class="params">()</span></span> <span class="comment">//访问队首元素</span></span><br><span class="line"><span class="function"><span class="title">back</span><span class="params">()</span></span>  <span class="comment">//访问队尾元素</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>常用函数<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pop</span><span class="params">()</span></span>   <span class="comment">//队首元素出队 O(1)</span></span><br><span class="line"><span class="function"><span class="title">empty</span><span class="params">()</span></span> <span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span></span>  <span class="comment">//返回元素个数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p> 优先队列，底层采用堆来实现。队首元素优先级最高。</p><ul><li><p>priority_queue元素优先级设置</p><p>对于基本数据类型，一般是大的优先级高，下面两种定义的方式是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure><p>vector<int>参数填写的是承载底层数据结构的容器，第三个参数less<int>,表示数字越大，优先级越高；而greater<int>表示数字越小优先级越高。</int></int></int></p></li><li><p>结构体优先级设置<br>重载小于号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(fruit f1,fruit f2)</span><br><span class="line"><span class="keyword">return</span> f1.price&lt;f2.price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义之后，价格高的排在队首。如果把小于号改为大于号，则价格低的排在队首。</p></li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul><li>定义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure></li></ul><ul><li>元素访问及常用函数<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">top</span><span class="params">()</span></span>  <span class="comment">//访问栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">push</span><span class="params">()</span></span> <span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="title">pop</span><span class="params">()</span></span>  <span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="title">empty</span><span class="params">()</span></span> <span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span></span>  <span class="comment">//返回元素个数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>头文件#include<utility>,map内部实现了pair，在添加map头文件时，也会自动添加utility头文件。</utility></p><ul><li>定义：<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;typename1,typename2&gt; name;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>,int&gt; p(<span class="string">"hello"</span>,<span class="number">5</span>) <span class="comment">//添加括号直接进行初始化</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>元素的访问</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.first<span class="comment">;</span></span><br><span class="line">p.second<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>pair常用函数<br>比较操作数：直接用比较符进行比较，比较规则：先以first大小作为标准，当first相等时，然后以second大小作为标准</p></li><li><p>用途</p><p>作为map的键值对插入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">mp.insert(make_pair(<span class="string">"hello"</span>,<span class="number">5</span>));</span><br><span class="line">mp.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"helllo"</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="algorithm头文件常用函数"><a href="#algorithm头文件常用函数" class="headerlink" title="algorithm头文件常用函数"></a>algorithm头文件常用函数</h3><ul><li>max() min() abs(int a)    最大值 最小值 绝对值</li><li>swap(x,y)                 交换x,y的值</li><li>reverse(it,it2)           将[it,it2)之间的元素进行反转</li><li>next_permutation()        给出一个序列在全排列中的下一个序列</li><li>fill()                   把数组或者容器内某一段区间赋为某个相同的值，可以是任意的值<br><strong>和memset()函数不同，memset只能赋值为0或1</strong></li><li>sort()  排序函数</li><li>lower_bound(first,last,val)    用来寻找数组或者容器中[first,last)范围内第一个<strong>大于或等于</strong>val的元素，返回指针或迭代器</li><li>upper_bound(first,last,val)    用来寻找数组或者容器中[first,last)范围内第一个<strong>大于</strong>val的元素，返回指针或迭代器<br><strong>如果没有要寻找的元素，则返回可以插入该元素的位置指针或迭代器</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：变长数组&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt;&amp;gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;gt;; &lt;span class=&quot;comment&quot;&gt;//二维数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://xxyxt.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>爱奇艺20届春招编程题1</title>
    <link href="https://xxyxt.github.io/2019/04/01/%E7%88%B1%E5%A5%87%E8%89%BA20%E5%B1%8A%E6%98%A5%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%981/"/>
    <id>https://xxyxt.github.io/2019/04/01/爱奇艺20届春招编程题1/</id>
    <published>2019-04-01T13:46:48.449Z</published>
    <updated>2019-04-01T15:04:11.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：根据自己的回忆写出题目大概的意思"><a href="#题目：根据自己的回忆写出题目大概的意思" class="headerlink" title="题目：根据自己的回忆写出题目大概的意思"></a>题目：根据自己的回忆写出题目大概的意思</h3><p>输入一串只包含数字的字符串str和一个整数k，从字符串中剔除k个数字，使剩下的字符串按照原来的顺序，得到的整数最小，输出这个整数。字符串长度N&lt;=240，k&lt;=N。<br>示例1:<br>输入：12553 2<br>输出：123<br>示例2：<br>输入：100050 4<br>输出：0</p> <a id="more"></a><p>错误思路：考试的时候，思路想错了，结果导致浪费了时间，所以拿到题目一定不能上来就敲代码，一定得想清楚想明白再开始码字。<br>去掉字符串中k个最大的字符，然后将剩下的字符按照原来的顺序排列就是最小值。操之过急，把问题过于简单化，结果在这个死路上越走越远，想回头已经来不及了。</p><p>正确解法：去除k个最大的字符得到的不一定是最小的。要从第一位字符str[0]开始往后遍历，直到遍历str[i+1]&lt;str[i]为止，将str[i]删除；如果一直递增，则删除最后一个。就好比爬山一样，如果一直是上坡的话，则一直往前走；直到碰到第一个下坡，则把前面的一个坡给削平；如果一直是上坡，则把最后一个坡给削平。<br>代码如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include&lt;string&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">void</span> Delete(string &amp;<span class="keyword">str</span>)  <span class="comment">//删除一个字符，使得剩下的最小</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="keyword">str</span>.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">str</span>[i+<span class="number">1</span>]&gt;=<span class="keyword">str</span>[i] &amp;&amp; i&lt;len)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">str</span>.erase(<span class="keyword">str</span>.begin()+i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">str</span>.erase(<span class="keyword">str</span>.begin()+len<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> strToNum(string <span class="keyword">str</span>)  <span class="comment">//字符串转化为整型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="keyword">str</span>.length();</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">sum</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">sum</span>+=<span class="keyword">str</span>[i]-<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">sum</span>=<span class="keyword">sum</span>*<span class="number">10</span>+<span class="keyword">str</span>[i]-<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">string <span class="keyword">str</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">cin&gt;&gt;<span class="keyword">str</span>&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">str</span>.length()==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Delete(<span class="keyword">str</span>);  <span class="comment">//调用k次</span></span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;strToNum(<span class="keyword">str</span>);</span><br><span class="line">returnl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目：根据自己的回忆写出题目大概的意思&quot;&gt;&lt;a href=&quot;#题目：根据自己的回忆写出题目大概的意思&quot; class=&quot;headerlink&quot; title=&quot;题目：根据自己的回忆写出题目大概的意思&quot;&gt;&lt;/a&gt;题目：根据自己的回忆写出题目大概的意思&lt;/h3&gt;&lt;p&gt;输入一串只包含数字的字符串str和一个整数k，从字符串中剔除k个数字，使剩下的字符串按照原来的顺序，得到的整数最小，输出这个整数。字符串长度N&amp;lt;=240，k&amp;lt;=N。&lt;br&gt;示例1:&lt;br&gt;输入：12553 2&lt;br&gt;输出：123&lt;br&gt;示例2：&lt;br&gt;输入：100050 4&lt;br&gt;输出：0&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://xxyxt.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://xxyxt.github.io/2019/04/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://xxyxt.github.io/2019/04/01/排序算法总结/</id>
    <published>2019-04-01T09:28:02.635Z</published>
    <updated>2019-04-01T14:43:34.863Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是最常用的一种算法，在面试中也会经常被问到，今天以升序为例总结一下集中常用的排序算法，以及复杂度和稳定性。</p><p><strong>关于稳定性</strong>：稳定性指的是一组数据中如果存在相等的数据，Ai=Aj，排序前Ai在Aj的前面，那么排序后Ai仍然在Aj的前面，那么这种排序算法就是稳定的，反正则是不稳定的。</p><p>常见的排序算法有：</p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>快速排序</li><li>堆排序</li><li><p>希尔排序</p><a id="more"></a><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3></li><li><p>排序思想：冒泡排序的核心思想就是比较相邻两个变量的大小，然后将不符合顺序的两个变量交换位置。如果有n个变量，则需要n-1趟比较，第一趟比较将最大值排序到倒数第一的位置，第二趟排序将次大值排序到倒数第二的位置……直到第n-1趟比较，可以将所有的变量都回归到正确的位置。时间复杂度为O(n^2)。很显然，冒泡排序是一种稳定的排序算法。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>* &amp;a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(a[j],a[j+<span class="number">1</span>]);<span class="comment">// swap函数交换位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>排序思想：顾名思义，选择排序就是将n个元素中最小的一个挑选出来放在第0号位置，然后将剩下的n-1个元素中挑选最小的元素放在第<br>1号位置……经过n-1次挑选，可以将全部的元素回归到正确的位置。时间复杂度为O(n^2)。选择排序是一种不稳定排序算法，每次交换位置，都有可能会打乱原来元素的相对位置，所以是一种不稳定的算法。代码如下：<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void selection_sort(<span class="keyword">int</span>* &amp;a,<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,<span class="keyword">pos</span>,temp<span class="comment">;</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span><span class="comment">;i&lt;n-1;i++)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pos</span>=i<span class="comment">;</span></span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span><span class="comment">;j&lt;n;j++)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[<span class="keyword">pos</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pos</span>=j<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a[<span class="keyword">pos</span>],a[i])<span class="comment">;// swap函数交换位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><p>排序思想：有排序完毕的一组数据a1,a2,……av，现在将第v+1个数据，插入到这组有序的数据中，需要找到第一个小于或等于a[v+1]的数，插入到其后。如果有n个元素，则需要进行n-1次插入操作，每次插入操作都不会打乱原来相等元素的相对位置，所以插入排序是稳定算法。时间复杂度为O(n^2)。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>* &amp;a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,v;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">v=a[i];</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; a[j]&gt;v;j--)</span><br><span class="line">&#123;</span><br><span class="line">a[j+<span class="number">1</span>]=a[j];<span class="comment">// 如果v的值小于a[j]的值，则将a[j]的值向后移动</span></span><br><span class="line">&#125;</span><br><span class="line">a[j+<span class="number">1</span>]=v;  <span class="comment">//将a[i]的值放入第一个小于或者等于a[i]的后面一个位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>排序思想：假设有n个元素的数组a[n]，选择一个基准元素，一般选取a[0]。设置左右遍历索引，low=0,high=n-1。先从右往左遍历，直到遇到第一个小于a[0]的元素，然后交换位置；然后从左往右遍历，直到遇到第一个大于a[0]的元素，然后交换位置。如果high的值小于或者等于low，则遍历结束。此时low位置将序列分为两个部分[0,low-1]和[low+1,n-1]，对这两个序列分别进行快速排序，即可得到排序结果。排序时间复杂度为O(n*logn)。是一个不稳定排序算法。代码如下：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void <span class="type">Quick_sort</span>(int* &amp;a,int <span class="keyword">left</span>,<span class="keyword">right</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">left</span>&lt;<span class="keyword">right</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">int low=<span class="keyword">left</span>;</span><br><span class="line">int high=<span class="keyword">right</span>;</span><br><span class="line">int temp=a[low];</span><br><span class="line"><span class="keyword">while</span>(low&lt;high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(high&gt;low &amp;&amp; a[high]=&gt;temp)</span><br><span class="line">&#123;</span><br><span class="line">high--；</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[high],a[low]); <span class="comment">//当high==low时，交换也没有影响，所以这里不需要判断，直接进行交换</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=temp)</span><br><span class="line">&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[high],a[low]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Quick_sort</span>(a,<span class="keyword">left</span>,low-<span class="number">1</span>);</span><br><span class="line"><span class="type">Quick_sort</span>(a,low+<span class="number">1</span>,<span class="keyword">right</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>排序思想：利用堆这种数据结构的特殊性，来进行排序。首先数组元素的小标索引应该从1开始，第i个节点左右子节点分别为i<em>2和i</em>2+1。首先自底向上建堆，然后取堆顶元素和最后一个元素进行交换，再对堆顶元素的位置进行调整。再去倒数第二个元素和堆顶元素进行交换，再次调整堆顶元素的位置，直到堆中只有一个数据为止。时间复杂度为O(n*logn)。代码如下：<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void downAdjust(int* &amp;a,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">int <span class="built_in">i</span>=low,<span class="built_in">j</span>=<span class="built_in">i</span>*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">j</span>&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">j</span>+<span class="number">1</span>&lt;=high &amp;&amp; a[<span class="built_in">j</span>+<span class="number">1</span>]&gt;a[<span class="built_in">j</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">j</span>=<span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="built_in">i</span>]&lt;a[<span class="built_in">j</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(a[<span class="built_in">i</span>],a[<span class="built_in">j</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void creatHeap(int* &amp;a,int n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=n/<span class="number">2</span>;<span class="built_in">i</span>&gt;=<span class="number">1</span>;<span class="built_in">i</span>--)</span><br><span class="line">&#123;</span><br><span class="line">downAdjust(<span class="built_in">i</span>,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void heapSort(int* &amp;a,n)</span><br><span class="line">&#123;</span><br><span class="line">creatHeap(a,n);</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=n;<span class="built_in">i</span>&gt;<span class="number">1</span>;<span class="built_in">i</span>--)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[<span class="built_in">i</span>],a[<span class="number">1</span>]);</span><br><span class="line">downAdjust(<span class="number">1</span>,<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法是最常用的一种算法，在面试中也会经常被问到，今天以升序为例总结一下集中常用的排序算法，以及复杂度和稳定性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于稳定性&lt;/strong&gt;：稳定性指的是一组数据中如果存在相等的数据，Ai=Aj，排序前Ai在Aj的前面，那么排序后Ai仍然在Aj的前面，那么这种排序算法就是稳定的，反正则是不稳定的。&lt;/p&gt;
&lt;p&gt;常见的排序算法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;&lt;p&gt;希尔排序&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://xxyxt.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python多线程多进程相关问题</title>
    <link href="https://xxyxt.github.io/2019/03/29/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://xxyxt.github.io/2019/03/29/python多线程多进程相关问题/</id>
    <published>2019-03-29T02:13:48.469Z</published>
    <updated>2019-03-29T02:24:46.892Z</updated>
    
    <content type="html"><![CDATA[<p>在线考试 本次考试成绩：55 答题剩余时间0小时43分9秒<br>考生须知<br>1.本次周考结束后，剩余补考次数：2次<br>2.周考时间为60分钟，超时系统自动交卷<br>3.本次考试满分100分（5*20道），60分通过考试<br>1.<br>(单选题)三个进程共享四个同类资源，这些资源的分配与释放只能一次一个。已知每一个进程最多需要两个该类资源，则该系统( )。<br> A.有些进程可能永远得不到该类资源<br> B.必然有死锁<br> C.进程请求该类资源立刻能得到<br> D.无<br> <a id="more"></a><br>正确答案：C<br>解析：<br>不会发生死锁。因为每个进程都分得一个资源时，还有一个资源可以让任意一个进程满足，这样这个进程可以顺利运行完成进而释放它的资源<br>我要反馈<br>2.<br>(单选题)一个队列的入队序列是a、b、c、d，则队列的输出序列为（）<br> A.abcd<br> B.dcba<br> C.acdb<br> D.bcda<br>正确答案：A<br>解析：<br>队列是先进先出的<br>我要反馈<br>3.<br>(单选题)下列关于管道通信的叙述中，正确的是 （）<br> A.一个管道可实现双向数据传输<br> B.管道的容量仅受磁盘容量大小限制<br> C.进程对管道进行读操作和写操作都可以被阻塞<br> D.一个管道只能有一个读写进程或一个写进程对其操作<br>正确答案：C<br>解析：<br>管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）在管道的头部读出数据。数据被一个进程读出后，将被从管道中删除，其它读进程将再不能读到这些数据。管道提供了简单的流控制机制，进程试图读空管道时，进程将阻塞。同样，管道已经满时，进程再试图向管道写入数据，进程将阻塞。<br>管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K（这里现在为65536byte）字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。<br>我要反馈<br>4.<br>(单选题)下面有关孤儿进程和僵尸进程的描述，说法错误的是？<br> A.孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。<br> B.僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程<br> C.孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作<br> D.孤儿进程和僵尸进程都可能使系统不能产生新的进程，都应该避免<br>正确答案：D<br>解析：<br>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p><p>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p><p>如果进程不调用wait / waitpid的话，  那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p><p>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上 ，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。 因此孤儿进程并不会有什么危害。<br>我要反馈<br>5.<br>(单选题)对于两个并发进程，设互斥信号量为 mutex ，且初始值为 1 ，若 mutex=1 ，则（ ）。<br> A.表示没有进程进入临界区<br> B.表示有一个进程进入临界区<br> C.表示有一个进程进入临界区，另一个进程等待进入<br> D.表示有两个进程进入临界区<br>正确答案：A<br>解析：<br>mutex=1时，表示两个进程皆未进去需要互斥的临界区，mutex=0时表示有一个进程进去临界区运行，另外一个必须等待，挂入阻塞队列，mutex=-1时表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒<br>我要反馈<br>6.<br>(单选题)有关多线程，多进程的描述错误的是？（    ）<br> A.子进程获得父进程的数据空间，堆和栈的复制品<br> B.线程可以与同进程的其他线程共享数据，但是它拥有自己的栈空间且拥有独立的执行序列<br> C.线程执行开销小，但是不利于资源管理和保护<br> D.进程是CPU调度和分派的基本单位。<br>正确答案：D<br>解析：<br>解析：线程是CPU调度和分派的基本单位。 进程是操作系统的基本单位。<br>我要反馈<br>7.<br>(单选题)启动线程时不调用start()而使用调用run()方法，会有什么后果<br> A.不会启动新线程，run方法也不会执行。<br> B.不会启动新线程，但是run方法会执行。<br> C.启动了新线程，但是run方法不会被执行。<br> D.启动了新线程，run方法也会被执行。<br>正确答案：B<br>解析：<br>start()方法执行之后表面上看起来直接执行run()方法，但是两者是有很大差别的：<br>run()方法只是一个类中的普通方法，直接执行和普通的方法没有上面两样<br>就相当于对象调用方法，执行方法<br>我要反馈<br>8.<br>(单选题)在多进程的系统里,一个进程已经占有足够的资源,如果还占有更多的资源会引起什么现象？<br> A.饥饿<br> B.死锁<br> C.同步<br> D.互斥<br>正确答案：B<br>解析：<br>1：饥饿是指一个可运行的进程尽管能继续执行，但被调度程序无限期地忽略，而不能被调度执行的情形。<br>2：死锁是两个或两个以上的进程其中每个进程都在等待其它进程做完某些事而不能继续执行。<br>3：互斥是当一个进程在临界区访问共享资源时，其它进程不能进入该临界区访问任何共享资源。<br>4：同步比较好理解<br>题目中说一个进程已经占有很多资源了，它还需要更多的资源，所以在没得到这些资源之前，它所占有的这些资源不能得到释放，其它进程就无法获得这些资源，而改程序所需要的资源也很可能被其它进程所占有，因此造成死锁；<br>我要反馈<br>9.<br>(多选题)关于多进程并发和多线程编程，以下哪些说法正确的（）<br> A.对于计算密集型程序，多进程并发优于多线程并发<br> B.多进程并发即运行多个独立的程序，优势在于并发处理的任务都由操作系统管理<br> C.多线程并发则由程序员管理并处理并发任务，这种并发方式可以方便地在线程之间共享数据（前提是不能互斥）<br> D.以上说法均不正确<br>正确答案：ABC<br>解析：<br>本题考查多进程并发多线程并发基础知识<br>我要反馈<br>10.<br>(单选题)可以让多个线程顺序执行的方法是（）<br> A.sleep()<br> B.wait()<br> C.interrupt()<br> D.join()<br>正确答案：D<br>解析：<br>join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。<br>我要反馈<br>11.<br>(单选题)下列几种关于进程的叙述，（）最不符合操作系统对进程的理解？<br> A.进程是在多程序并行环境中的完整的程序<br> B.进程可以由程序、数据和进程控制块描述<br> C.线程是一种特殊的进程<br> D.进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位<br>正确答案：A<br>解析：<br>链接：<a href="https://www.nowcoder.com/questionTerminal/3d94695d207f4391895fb4bfd357e941" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/3d94695d207f4391895fb4bfd357e941</a><br>来源：牛客网</p><p>进程 （Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本 区域（text region）、数据区域（data region）和堆栈 （stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理 器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。<br>我要反馈<br>12.<br>(单选题)下列不是进程间的通信方式的是（）<br> A.管道<br> B.回调<br> C.共享内存<br> D.socket<br>正确答案：B<br>解析：<br>1.管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>2.信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>3.消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>4.共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 </p><ol start="5"><li>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信<br>6.回调： 是一种编程机制<br>我要反馈<br>13.<br>(单选题)关于程序和进程，以下哪种说法是正确的<br>A.程序是动态的，进程是静态的<br>B.程序是静态的，进程是动态的<br>C.程序和进程都是动态的<br>D.程序和进程都是静态的<br>正确答案：B<br>解析：<br>本题考查程序和进程的区别。<br>我要反馈<br>14.<br>(多选题)下列属于事件方法的是（）<br>A.wait<br>B.clear<br>C.set<br>D.以上都不是<br>正确答案：ABC<br>解析：<br>python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法wait、clear、set</li></ol><p>事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。</p><p>clear：将“Flag”设置为False<br>set：将“Flag”设置为True<br>我要反馈<br>15.<br>(多选题)下列关于程序说法正确的是<br> A.我们写好的软件，存放在磁盘上可以叫做程序<br> B.一个程序包括，需要执行的指令和数据（0/1）<br> C.一个程序就是存放到磁盘上的文件<br> D.程序是磁盘上存在的静态实体<br>正确答案：ABCD<br>解析：<br>此题考查程序的概念，ABCD都为正确选项<br>我要反馈<br>16.<br>(单选题)栈和队列的共同特点是：<br> A.都是先进先出<br> B.都是先进后出<br> C.只允许在端点处插入和删除元素<br> D.没有共同点<br>正确答案：C<br>解析：<br>遵循原则:<br>队列:先进先出<br>栈:先进后出(后进先出)<br>无论先进先出还是先进后出都是在端点处插入和删除元素.<br>我要反馈<br>17.<br>(多选题)下列关于进程池说法正确的是（）<br> A.python中，进程池内部会维护一个进程序列。当需要时，程序会去进程池中获取一个进程<br> B.如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。<br> C.apply 从进程池里取一个进程并同步执行<br> D.apply_async 从进程池里取出一个进程并异步执行<br>正确答案：ABCD<br>解析：<br>此题考查进程池的概念以及方法<br>我要反馈<br>18.<br>(多选题)下列关于共享内存说法正确的是（）<br> A.进程共享同一块内存空间<br> B.访问共享内存和访问私有内存一样快<br> C.不需要系统调用和内核出口<br> D.造成不必要的内存复制<br>正确答案：ABC<br>解析：<br>D选项错误，是不造成不必要的内存复制<br>我要反馈<br>19.<br>(单选题)建立多进程的主要目的是提高（ ）的利用率<br> A.文件<br> B.CPU<br> C.内存<br> D.外设<br>正确答案：B<br>解析：<br>想要充分利用多核CPU资源，Python中大部分情况下都需要使用多进程，Python中提供了multiprocessing这个包实现多进程。multiprocessing支持子进程、进程间的同步与通信，提供了Process、Queue、Pipe、Lock等组件。<br>我要反馈<br>20.<br>(单选题)进程的基本特性是（）<br> A.进程是动态的、多个进程可以含有相同的程序和多个进程可以并行运行<br> B.进程是动态的、多个进程对应的程序必须是不同的和多个进程可以并发运行<br> C.进程是动态的、多个进程可以含有相同的程序和多个进程不能并发运行<br> D.进程是静态的、多个进程可以含有相同的程序和多个进程可以并发运行<br>正确答案：A<br>解析：<br>本题考查进程的概念<br>我要反馈<br>Copyright(C) 达内时代科技集团有限公司 2011-2013 tarena.com.cn 返回顶部</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在线考试 本次考试成绩：55 答题剩余时间0小时43分9秒&lt;br&gt;考生须知&lt;br&gt;1.本次周考结束后，剩余补考次数：2次&lt;br&gt;2.周考时间为60分钟，超时系统自动交卷&lt;br&gt;3.本次考试满分100分（5*20道），60分通过考试&lt;br&gt;1.&lt;br&gt;(单选题)三个进程共享四个同类资源，这些资源的分配与释放只能一次一个。已知每一个进程最多需要两个该类资源，则该系统( )。&lt;br&gt; A.有些进程可能永远得不到该类资源&lt;br&gt; B.必然有死锁&lt;br&gt; C.进程请求该类资源立刻能得到&lt;br&gt; D.无&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="https://xxyxt.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://xxyxt.github.io/2019/03/28/%E5%A0%86/"/>
    <id>https://xxyxt.github.io/2019/03/28/堆/</id>
    <published>2019-03-28T07:59:25.418Z</published>
    <updated>2019-03-28T08:43:54.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义与基本操作"><a href="#定义与基本操作" class="headerlink" title="定义与基本操作"></a>定义与基本操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>堆是一棵完全二叉树，每个节点的值都不大于(小顶堆)或者不小于(大顶堆)其左右节点的值</li><li>堆一般用于优先队列的实现<a id="more"></a></li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>如果用数组来存储一棵完全二叉树，根节点存储在1号位置，则第i号位表示的节点的左子树和右子树分别为2i和2i+1</p><ul><li>向下调整</li></ul><p>将当前节点和其左右子节点进行比较，如果子节点的值存在大于当前节点的值，则将权值中较大的子节点的值和当前节点的值进行交换；<br>继续比较当前节点和其子节点，直到子节点的值都小于当前节点的值，代码如下：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void downAdjust(int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">int <span class="built_in">i</span>=low,<span class="built_in">j</span>=<span class="built_in">i</span>*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">j</span>&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">j</span>+<span class="number">1</span>&lt;=high &amp;&amp; heap[<span class="built_in">j</span>+<span class="number">1</span>]&gt;heap[<span class="built_in">j</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">j</span>=<span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(heap[<span class="built_in">j</span>]&gt;heap[<span class="built_in">i</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[<span class="built_in">j</span>],heap[<span class="built_in">i</span>]);</span><br><span class="line"><span class="built_in">i</span>=<span class="built_in">j</span>;</span><br><span class="line"><span class="built_in">j</span>=<span class="built_in">i</span>*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>向上调整</li></ul><p>和向下调整相反，向上调整总是将欲调整的元素和其父节点比较，代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void upAdjust(int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">int <span class="built_in">i</span>=high,<span class="built_in">j</span>=<span class="built_in">i</span>/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">j</span>&gt;=low)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(heap[<span class="built_in">j</span>]&lt;heap[<span class="built_in">i</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[<span class="built_in">j</span>],heap[<span class="built_in">i</span>]);</span><br><span class="line"><span class="built_in">i</span>=<span class="built_in">j</span>;</span><br><span class="line"><span class="built_in">j</span>=<span class="built_in">i</span>/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>建堆</li></ul><p>二叉树中元素个数为n,完全二叉树叶子节点个数为n/2，因此下标[1,n/2]范围内都是非叶子节点。<br>代码如下：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void creatHeap()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=n/<span class="number">2</span>;<span class="built_in">i</span>&gt;=<span class="number">1</span>;<span class="built_in">i</span>--)</span><br><span class="line">&#123;</span><br><span class="line">downAdjust(<span class="built_in">i</span>,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>删除元素</li></ul><p>以删除堆定元素为例，代码如下：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void deleteTop()</span><br><span class="line">&#123;</span><br><span class="line">heap<span class="string">[1]</span>=heap<span class="string">[n--]</span>;</span><br><span class="line">downAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>添加元素</li></ul><p>在数组的末尾添加一个元素，然后向上调整新加入的节点，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[++n]=x;</span><br><span class="line">upAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>堆排序</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void heapSort()</span><br><span class="line">&#123;</span><br><span class="line">creatHeap();</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=n;<span class="built_in">i</span>&gt;<span class="number">1</span>;<span class="built_in">i</span>--)</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[<span class="built_in">i</span>],heap[<span class="number">1</span>]);</span><br><span class="line">downAdjust(<span class="number">1</span>,<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义与基本操作&quot;&gt;&lt;a href=&quot;#定义与基本操作&quot; class=&quot;headerlink&quot; title=&quot;定义与基本操作&quot;&gt;&lt;/a&gt;定义与基本操作&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;堆是一棵完全二叉树，每个节点的值都不大于(小顶堆)或者不小于(大顶堆)其左右节点的值&lt;/li&gt;
&lt;li&gt;堆一般用于优先队列的实现
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++/数据结构" scheme="https://xxyxt.github.io/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xxyxt.github.io/2019/03/05/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2DFS/"/>
    <id>https://xxyxt.github.io/2019/03/05/深度优先搜索DFS/</id>
    <published>2019-03-05T13:43:37.368Z</published>
    <updated>2019-03-05T13:43:37.454Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反射机制</title>
    <link href="https://xxyxt.github.io/2019/02/28/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://xxyxt.github.io/2019/02/28/反射机制/</id>
    <published>2019-02-28T10:32:56.347Z</published>
    <updated>2019-02-28T12:39:34.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>在正常的类的使用中，一般是先确定类，然后使用<strong>new</strong>关键字产生实例化对象然后使用。如果想通过对象取得类的信息，那么可以使用Object类中的getClass()方法。<br>反射机制的初步操作如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo18</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">Date data=<span class="keyword">new</span> <span class="type">Date</span>();</span><br><span class="line">System.out.println(data.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class java<span class="selector-class">.util</span><span class="selector-class">.Date</span></span><br></pre></td></tr></table></figure></p><p><strong>Class类对象实例化的三种方式</strong></p><ul><li>getClass() 使用此类必须要有实例化对象</li><li>类.class 不需要实例化对象</li><li>调用Class类提供的方法：public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException</li></ul><h2 id="反射实例化对象"><a href="#反射实例化对象" class="headerlink" title="反射实例化对象"></a>反射实例化对象</h2><p>实例化Class对象后，就可以利用Class类来进行类的反射控制，Class类的常用方法如下：</p><ul><li>public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException  通过字符串设置类名称实例化Class对象</li><li>public Class&lt;?&gt;[] getInterface() 取得类实现的所有接口</li><li>public String getName() 取得反射操作类全名</li><li>public String getSimpleName() 取得反射操作类名，不包括包名</li><li>public Package getPackage() 取得反射操作类所在的包</li><li>public Class&lt;? super T&gt; getSuperclass() 取得反射操作类的父亲</li><li>public boolean isEnum() 反射操作类是否是枚举</li><li>public boolean isInterface() 反射操作类是否是接口</li><li>public boolean isArray() 反射操作类是否是数组</li><li>public T newInstance() throws  反射实例化对象</li></ul><p>通过newStance()方法，可以实例化Class类包装的类型，不使用关键字new也可以进行对象的实例化操作。<br>注：<strong>使用newStance()方法进行实例化，类中一定要有无参构造方法，否则会出错</strong></p><p>利用反射实例化对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo19</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Class&lt;?&gt; cls=Class.forName(<span class="string">"Test1.Book"</span>);</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">Object obj=cls.newInstance();</span><br><span class="line">Book book=(Book) obj;</span><br><span class="line">System.out.println(book);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本程序通过实例化Class类，然后利用newStance()方法进行类包装的对象的实例化，实例化的对象是Object类，需要向下转型强制变为子类。</p><h2 id="反射调用构造"><a href="#反射调用构造" class="headerlink" title="反射调用构造"></a>反射调用构造</h2><p>使用newStance()方法实例化对象，必须要求类里面存在无参构造方法，如果类中没有无参构造方法的话，就必须通过<strong>java.lang.reflect.Constructor</strong>类来实现对象的反射实例化操作。<br>java.lang.Class取得构造方法的操作如下：</p><ul><li>public Constructor&lt;?&gt;[] getConstructors() throws SecurityException 取得全部的构造方法</li><li>public Constructor<t> getConstructor(Class&lt;?&gt; parameterTypes) throws 取得指定类型的构造方法</t></li></ul><p>Java.lang.reflect.Constructor类常用的操作方法如下：</p><ul><li>public Class&lt;?&gt;[] getExceptionTypes() 取得构造方法上所有抛出异常的类型</li><li>public int getNodifiers() 取得构造方法上的修饰符</li><li>public String getName() 取得构造方法的名字</li><li>public getParameterCount() 取得构造方法中的参数的个数</li><li>public Class&lt;?&gt;[]getParameterTypes() 取得构造方法中的参数类型</li><li>public T newInstance(Object…initargs) 调用指定参数的构造实例化对象</li></ul><p>明确调用勒种有参构造<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test2;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String title;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String title,<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.title=title;</span><br><span class="line"><span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"名字："</span>+<span class="keyword">this</span>.title+<span class="string">",价格："</span>+<span class="keyword">this</span>.price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">Class&lt;?&gt; cls=Class.forName(<span class="string">"Test2.Book"</span>);</span><br><span class="line">Constructor&lt;?&gt; con=cls.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">Object obj=con.newInstance(<span class="string">"中国上下五千年"</span>,<span class="number">199</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="反射调用方法"><a href="#反射调用方法" class="headerlink" title="反射调用方法"></a>反射调用方法</h2><p>常用“对象.方法()”调用方法，利用反射机制也可以实现类方法的操作<br>Class类取得方法的操作：</p><ul><li>public Methode[] getMethod() throws SecurityException 取得类中全部的方法</li><li>public Method getMethod(String name,Class&lt;?&gt; parameterTypes) throws 取得类中指定名称与参数类型的方法</li></ul><p>Method常用方法如下：</p><ul><li>public int getModifiers() 取得方法的修饰符</li><li>public Class&lt;?&gt; getReturnType() 取得方法的返回值类型</li><li>public int getParameterCount() 取得方法中定义的参数数量</li><li>public Class&lt;?&gt;[] getParameterTypes() 取得方法定义中参数类型</li><li>public Object invoke(Object obj,Object…args) throws Exception 反射调用方法并执行方法中所需要的参数</li><li>public Class&lt;?&gt;[] getExceptionTypes() 取得方法抛出的异常类型</li></ul><p>使用反射类操作java类属性<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test2;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line">class Book2&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> title;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> setTitle(<span class="keyword">String</span> title) &#123;</span><br><span class="line"><span class="keyword">this</span>.title=title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> getTitle() &#123;</span><br><span class="line"><span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class testDemo2 &#123;</span><br><span class="line">@SuppressWarnings(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="keyword">String</span> fieldName=<span class="string">"title"</span>;</span><br><span class="line">Class&lt;?&gt; cls=Class.forName(<span class="string">"Test2.Book2"</span>);</span><br><span class="line"><span class="keyword">Object</span> obj=cls.newInstance();</span><br><span class="line">Method setMet=cls.getMethod(<span class="string">"set"</span>+initcap(fieldName), <span class="keyword">String</span>.class);</span><br><span class="line">Method getMet=cls.getMethod(<span class="string">"get"</span>+initcap(fieldName));</span><br><span class="line">setMet.invoke(obj, <span class="string">"Java开发"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(getMet.invoke(obj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> initcap(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">str</span>.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()+<span class="built_in">str</span>.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="反射调用成员"><a href="#反射调用成员" class="headerlink" title="反射调用成员"></a>反射调用成员</h2><p>除了构造方法，普通方法，反射类也可以进行成员的操作，Class类中成员的取得方法如下：</p><ul><li>public Field[] getDeclaredFields() throws SecurityException 取得本类定义的全部成员</li><li>public Field getDeclaredFields(String name) throws… 取得本类指定名称成员</li><li>public Field[] getFields() throws SecurityException  取得本类继承父类的全部成员</li><li>public Field getFields(String name) throws…  取得本类继承父类中指定的成员 </li></ul><p>Field类常用描述成员信息的方法如下：</p><ul><li>public Class&lt;?&gt; getType() 取得该成员的类型</li><li>public Object get(Object obj) throws… 取得指定对象中的成员内容</li><li>public void set(Object obj,Object value) throws… 设置指定对象中成员内容，相当于直接利用对象调用成员设置内容</li></ul><p>利用反射类操作私有成员：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test2;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book3</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDem03</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span> args[]) throws Exception&#123;</span><br><span class="line">Class&lt;?&gt; cls=Class.forName(<span class="string">"Test2.Book3"</span>);</span><br><span class="line">@SuppressWarnings(<span class="string">"deprecation"</span>)</span><br><span class="line">Object obj=cls.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line">Field titField=cls.getDeclaredField(<span class="string">"title"</span>);</span><br><span class="line">titField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">titField.<span class="keyword">set</span>(obj, <span class="string">"Java开发"</span>);</span><br><span class="line">System.out.println(titField.<span class="keyword">get</span>(obj));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是反射&quot;&gt;&lt;a href=&quot;#什么是反射&quot; class=&quot;headerlink&quot; title=&quot;什么是反射&quot;&gt;&lt;/a&gt;什么是反射&lt;/h2&gt;&lt;p&gt;在正常的类的使用中，一般是先确定类，然后使用&lt;strong&gt;new&lt;/strong&gt;关键字产生实例化对象然后使用。如
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类集框架</title>
    <link href="https://xxyxt.github.io/2019/02/26/Java%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"/>
    <id>https://xxyxt.github.io/2019/02/26/Java类集框架/</id>
    <published>2019-02-26T13:24:54.061Z</published>
    <updated>2019-02-27T06:51:39.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单对象保存父接口：Collection"><a href="#单对象保存父接口：Collection" class="headerlink" title="单对象保存父接口：Collection"></a>单对象保存父接口：Collection</h2><p><strong>定义</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Collection&lt;E&gt; extends Iterator&lt;E&gt;</span><br></pre></td></tr></table></figure></p><p><strong>核心方法</strong></p><ul><li>public boolean add(E e) 普通方法 向集合里面保存数据</li><li>public boolean addAll(Collection&lt;? extends E&gt; c) 普通方法 追加一个集合</li><li>public void clear() 普通方法 清空集合，跟元素为null</li><li>public boolean contains(Object o) 普通方法 判断是否含有指定内容，需要equals支持</li><li>public boolean isEmpty() 普通方法 判断是否是空集合</li><li>public boolean remove(Object o) 普通方法 删除对象，需要equals支持</li><li>public int size() 普通方法 取得集合中保存元素的个数</li><li>public Object[] toArray() 普通方法 将集合变为对象数组</li><li>public Inerator<e> iterator() 普通方法 为Iterator接口实例化</e></li></ul><a id="more"></a><p><strong>注意：</strong>contains()和remove()方法操作是，需要确保已经覆写了Object类中的equals()方法</p><p>Clooection的两个子接口：</p><ul><li>List(允许数据重复)</li><li>Set(数据不允许重复)</li></ul><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p><strong>List接口的方法扩充</strong></p><ul><li>public E get(int index) 普通方法 取得索引编号的内容</li><li>public E set(int index,E element) 普通方法 修改指定索引的内容</li><li>public ListIterator<e> listIterator() 普通方法 为ListIterator接口实例化</e></li></ul><p>注意：在使用List接口时，可以使用<strong>ArrayList</strong>或<strong>Vector</strong>两个子接口来进行接口对象的实例化</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>List基本操作<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> class testDemo&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[])&#123;</span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; all=<span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"长度："</span>+all.<span class="built_in">size</span>()+<span class="string">"，是否为空："</span>+all.isEmpty());</span><br><span class="line">all.<span class="built_in">add</span>(xxy);</span><br><span class="line">all.<span class="built_in">add</span>(xt);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"长度："</span>+all.<span class="built_in">size</span>()+<span class="string">"，是否为空："</span>+all.isEmpty());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> x=<span class="number">0</span>;x&lt;all.<span class="built_in">size</span>();x++)&#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=all.<span class="built_in">get</span>(x);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过ArrayList子类实例化List接口对象，这样就可以使用List接口中定义的方法，List接口相对于Collection接口扩充了get()方法，所以可以直接获取保存在集合的数据。<br>ArrayList是List接口的子类，同时也是Collection的子类，所以，可以直接用ArrayList实例化Collection接口。<br>直接使用Collection接口对象将不具备get()方法，只有将全部集合利用toArray()方法转化为对象数组后才可以输出。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>JDK1.2之后Vector实现了一个List接口，与ArrayList的最大区别就是Vector类中的部分方法使用了<strong>Synchronized</strong>关键字声明</p><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p>Set接口有两个常用的子类：</p><ul><li>HashSet：散列存放数据</li><li>TreeSet：有序存放数据(使用TreeSet子类必须同时使用比较器的概念)</li></ul><p><strong>HashSet子类的操作</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> class testDemo6 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Set&lt;<span class="keyword">String</span>&gt; all=<span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"xxy"</span>);</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"xt"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>TreeSet子类的操作</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> class testDemo7 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">Set&lt;<span class="keyword">String</span>&gt; all=<span class="keyword">new</span> TreeSet&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"xxy"</span>);</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"xt"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用TreeSet子类会默认实现排序功能，但是如果保存的是任意类的对象，则必须实现java.lang.Comparable接口才可以实现排序。</p><p><strong>利用TreeSet保存自定义对象,并实现排序功能</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Computer</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String name,<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.price=price;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"电脑的名字："</span>+<span class="keyword">this</span>.name+<span class="string">",电脑的价格："</span>+<span class="keyword">this</span>.price+<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Computer c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.price&gt;c.price) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price&lt;c.price) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(c.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo8</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Set&lt;Computer&gt; all=<span class="keyword">new</span> TreeSet&lt;Computer&gt;();</span><br><span class="line">all.add(<span class="keyword">new</span> Computer(<span class="string">"lenove"</span>,<span class="number">3999</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Computer(<span class="string">"apple"</span>,<span class="number">19999</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Computer(<span class="string">"xiaomi"</span>,<span class="number">4999</span>));</span><br><span class="line">System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，TreeSet数据的排序和消除重复元素都是依靠Compara接口</p><p><strong>利用HashSet保存自定义对象,并实现消除重复元素功能</strong><br>HashSet如果要消除重复元素，则需要依靠Object类中提供的两个方法：</p><ul><li>取得哈希码：public int hashCode()</li><li>对象比较：public boolean equals(Object obj)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glasses</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String material;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Glasses</span><span class="params">(String material,<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.material=material;</span><br><span class="line"><span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">result = prime * result + ((material == <span class="keyword">null</span>) ? <span class="number">0</span> : material.hashCode());</span><br><span class="line">result = prime * result + price;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Glasses other = (Glasses) obj;</span><br><span class="line"><span class="keyword">if</span> (material == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.material != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!material.equals(other.material))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (price != other.price)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"眼镜的材料："</span>+<span class="keyword">this</span>.material+<span class="string">",眼镜的价格："</span>+<span class="keyword">this</span>.price+<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo9</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Set&lt;Glasses&gt; all=<span class="keyword">new</span> HashSet&lt;Glasses&gt;();</span><br><span class="line">all.add(<span class="keyword">new</span> Glasses(<span class="string">"塑料"</span>,<span class="number">399</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Glasses(<span class="string">"金属"</span>,<span class="number">299</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Glasses(<span class="string">"塑料"</span>,<span class="number">399</span>));</span><br><span class="line">System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合的输出"><a href="#集合的输出" class="headerlink" title="集合的输出"></a>集合的输出</h2><p>4种形式：</p><ul><li>Iterator</li><li>ListIterator</li><li>foreach</li><li>Enumeration</li></ul><h3 id="迭代输出：Iterator"><a href="#迭代输出：Iterator" class="headerlink" title="迭代输出：Iterator"></a>迭代输出：Iterator</h3><p>Collection接口中直接为Iterator接口实例化的方法iterator()，任何集合都可以转换为Iterator接口输出</p><p><strong>Iterator接口定义的方法</strong></p><ul><li>public boolean hasNext() 普通方法 判断是否还有内容</li><li>public E next() 普通方法 取出当前内容</li></ul><p><strong>使用Iterator输出集合</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> class testDemo10 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; all=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"xxy"</span>);</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"xt"</span>);</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"zju"</span>);</span><br><span class="line">Iterator&lt;<span class="keyword">String</span>&gt; iter=all.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=iter.next();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向迭代输出：ListIterator"><a href="#双向迭代输出：ListIterator" class="headerlink" title="双向迭代输出：ListIterator"></a>双向迭代输出：ListIterator</h3><p>ListIterator属于Iterator的子接口</p><p><strong>ListIterator接口定义的方法</strong></p><ul><li>public boolean hasPrevious() 普通方法 判断是否有前一个元素</li><li>public E previous() 普通方法 取出前一个元素</li><li>public void add(E e) 普通方法 向集合中追加元素</li><li>public void set(E e) 普通方法 修改集合数据</li></ul><p>同时可以继续使用hasNext()方法和next()方法</p><h3 id="foreach输出"><a href="#foreach输出" class="headerlink" title="foreach输出"></a>foreach输出</h3><h3 id="Enumeration输出"><a href="#Enumeration输出" class="headerlink" title="Enumeration输出"></a>Enumeration输出</h3><p>接口定义：<br>如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;  <span class="comment">// 判断是否有下一个元素 相当于 hasNext()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span></span>;            <span class="comment">//取出当前元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>利用Enumeration接口输出数据</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> class testDemo11 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">Vector&lt;<span class="keyword">String</span>&gt; all=<span class="keyword">new</span> Vector&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"zju"</span>);</span><br><span class="line">all.<span class="built_in">add</span>(<span class="string">"xxy"</span>);</span><br><span class="line">Enumeration&lt;<span class="keyword">String</span>&gt; enu=all.elements();</span><br><span class="line"><span class="keyword">while</span>(enu.hasMoreElements()) &#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=enu.nextElement();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要利用集合类为Enumeration实例化，必须使用Vector子类完成</p><h2 id="偶对象保存：Map接口"><a href="#偶对象保存：Map接口" class="headerlink" title="偶对象保存：Map接口"></a>偶对象保存：Map接口</h2><p><strong>Map常用方法</strong></p><ul><li>public V put(K key,V value) 普通方法 向集合中保存数据</li><li>public v get(Object key) 普通方法 根据key值查找Value</li><li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 普通方法 将Map集合转化为Set集合</li><li>public Set<k> keySet() 普通方法 取出全部的key</k></li></ul><p>Map接口中常用的两个子类：</p><ul><li>HashTble</li><li>HashMap</li></ul><p><strong>HashMap子类的使用</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">public</span> class testDemo12 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">Map&lt;<span class="keyword">String</span>,Integer&gt; <span class="built_in">map</span>=<span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>,Integer&gt;();</span><br><span class="line"><span class="built_in">map</span>.put(<span class="string">"壹"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">map</span>.put(<span class="string">"空"</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="built_in">map</span>.put(<span class="keyword">null</span>,<span class="number">0</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出：</p><ul><li>HashMap定义的Map集合是无序存放的</li><li>前面如果与重复的key，会使用新的内容替换旧的内容</li><li>HashMap保存数据时，key或value可以保存为null</li></ul><p><strong>Hashtable子类的使用</strong><br>Hashtable保存的key或value值不能设置为null</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">public</span> class testDemo13 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">Map&lt;<span class="keyword">String</span>,Integer&gt; <span class="built_in">map</span>=<span class="keyword">new</span> Hashtable&lt;<span class="keyword">String</span>,Integer&gt;();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"壹"</span>,<span class="number">1</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"壹"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用Iterator输出Map集合"><a href="#利用Iterator输出Map集合" class="headerlink" title="利用Iterator输出Map集合"></a>利用Iterator输出Map集合</h3><p><strong>集合的输出要利用Iterator接口</strong><br>Collection接口可以直接实例化Iterator接口，但是Map接口并没有直接实例化的方法。<br>Map保存的对象是将key和value自动包装成一个Map.Entry接口对象<br>Map.Entry常用方法：</p><ul><li>public K getKey() 取得数据中的key</li><li>public VgetValue() 取得对象中的value</li><li>public V setValue(V value) 修改数据中的value</li></ul><p>虽然Map接口没有直接实例化Iterator的方法，但是有将Map接口数据转化为Set接口的方法：<strong>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</strong>,<br>然后可以利用Set接口实例化Iterator接口</p><p>利用Iterator输出Map集合<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">Map</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">Iterator</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">Set</span>;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">testDemo14</span> </span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[]) &#123;</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,Integer&gt; map=<span class="keyword">new</span> Hashtable&lt;<span class="built_in">String</span>,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"壹"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, Integer&gt;&gt; <span class="keyword">set</span>=map.entrySet();</span><br><span class="line"><span class="built_in">Iterator</span>&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, Integer&gt;&gt; iter=<span class="keyword">set</span>.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line"><span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, Integer&gt; me=iter.next();</span><br><span class="line">System.out.println(me.getKey()+<span class="string">"="</span>+me.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p><strong>常用操作</strong></p><ul><li>public static <t> boolean addAll(Collection&lt;? super T&gt; c,T elements) 实现集合数据追加</t></li><li>public static <t> int binarySearch(List&lt;? extends Comparable&lt;? supoer T&gt;&gt; list, T key) 二分法查找集合数据</t></li><li>public static <t> void copy(List&lt;?super T&gt; dest,List&lt;? extends T&gt; src) 集合复制</t></li><li>public stativ void reverse(List&lt;?&gt; list) 集合翻转</li></ul><p>追加数据<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> class testDemo15 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; all=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">Collections.addAll(all, <span class="string">"xxy"</span>,<span class="string">"zju"</span>,<span class="string">"zjg"</span>,<span class="string">"yq"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(all);</span><br><span class="line">Collections.<span class="built_in">reverse</span>(all);</span><br><span class="line">System.out.<span class="built_in">println</span>(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单对象保存父接口：Collection&quot;&gt;&lt;a href=&quot;#单对象保存父接口：Collection&quot; class=&quot;headerlink&quot; title=&quot;单对象保存父接口：Collection&quot;&gt;&lt;/a&gt;单对象保存父接口：Collection&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public&lt;span class=&quot;built_in&quot;&gt; interface &lt;/span&gt;Collection&amp;lt;E&amp;gt; extends Iterator&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public boolean add(E e) 普通方法 向集合里面保存数据&lt;/li&gt;
&lt;li&gt;public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) 普通方法 追加一个集合&lt;/li&gt;
&lt;li&gt;public void clear() 普通方法 清空集合，跟元素为null&lt;/li&gt;
&lt;li&gt;public boolean contains(Object o) 普通方法 判断是否含有指定内容，需要equals支持&lt;/li&gt;
&lt;li&gt;public boolean isEmpty() 普通方法 判断是否是空集合&lt;/li&gt;
&lt;li&gt;public boolean remove(Object o) 普通方法 删除对象，需要equals支持&lt;/li&gt;
&lt;li&gt;public int size() 普通方法 取得集合中保存元素的个数&lt;/li&gt;
&lt;li&gt;public Object[] toArray() 普通方法 将集合变为对象数组&lt;/li&gt;
&lt;li&gt;public Inerator&lt;e&gt; iterator() 普通方法 为Iterator接口实例化&lt;/e&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程与进程</title>
    <link href="https://xxyxt.github.io/2019/02/26/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <id>https://xxyxt.github.io/2019/02/26/线程与进程/</id>
    <published>2019-02-26T01:45:15.527Z</published>
    <updated>2019-02-26T08:54:25.089Z</updated>
    
    <content type="html"><![CDATA[<p>进程：程序的一次动态执行的过程，从代码加载到执行完毕的一整个过程。<br>线程：线程是比进程更小的一个单位，线程是在进程的基础上进一步进行划分，一个进程可以分为多个线程，这些线程同时存在同时运行。<br>多进程：多进程的操作系统可以同时运行多个程序，由于CPU具备分时机制，每个进程都可以循环获得自己的CPU时间，使进程看起来像同时进行一样。<br><a id="more"></a></p><h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><p>要想实现多线程程序，需要依靠一个线程的主体类，此类需要继承Thread类或实现Runnable(Callable)接口</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>任何类只需要继承Thread类就会成为一个线程的主类，线程的启动方法需要覆写Thread类的run()方法。<br>格式如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名称</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">属性...</span><br><span class="line">方法...</span><br><span class="line">public void run()&#123;</span><br><span class="line">线程主体方法；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>继承Thread类具有单继承的局限性，因此可以利用Runnable接口来实现多线程。<br>接口定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和Thread类一样，线程主类只需要覆写run()方法即可</p><h3 id="两种实现方式的区别"><a href="#两种实现方式的区别" class="headerlink" title="两种实现方式的区别"></a>两种实现方式的区别</h3><ul><li><p>Thread类的定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><p>Thread类是Runnable接口的子类</p></li><li><p>Runnable能更加方便的表示出数据共享的概念</p></li></ul><h3 id="实现有返回值的多线程操作"><a href="#实现有返回值的多线程操作" class="headerlink" title="实现有返回值的多线程操作"></a>实现有返回值的多线程操作</h3><p>Runnable接口解决了单继承局限的问题，但是不能反回操作结果，利用java.util.concurrent.Callable类可以解决返回值的问题<br><strong>接口定义：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>call()方法的返回值由接口上的泛型动态类型决定<br>主体类定义完成后，需要利用Thread类来启动多线程，但是Thread类没有接收Callable接口对象实例，因此提供了一个新类：<br>java.util.concurrent.FutureTask<v><br><strong>定义如下：</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FutureTask&lt;V&gt;</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="title">implements</span> <span class="title">RunnableFuture&lt;V&gt;</span></span></span><br></pre></td></tr></table></figure></v></p><p>FutureTask实现了RunnableFuture接口，而RunnableFuture接口又同时实现了Runnable和Future接口<br><strong>常用方法：</strong></p><ul><li>public FutureTask(Callable<v> callable) 构造方法 接收Callable接口实例</v></li><li>public FutureTask(Runnable runnable,V result) 构造方法 接收Runnable接口实例，指定返回类型</li><li>public V get() throws Interrupted Exception,ExecutionException 普通方法 取得线程操作结构</li></ul><h2 id="多线程常用操作方法"><a href="#多线程常用操作方法" class="headerlink" title="多线程常用操作方法"></a>多线程常用操作方法</h2><h3 id="命名与取得"><a href="#命名与取得" class="headerlink" title="命名与取得"></a>命名与取得</h3><p>线程执行，每一次运行都是不同的结果，因为他会根据自己的情况进行资源抢占。<br>线程命名操作：</p><ul><li>public Thread(Runnable target,String name) 构造方法 接收Runnable接口子类对象，同时设置线程名称</li><li>public final void setName(String name) 普通方法 设置线程名称</li><li>public final String getName()          普通方法 取得线程名称</li></ul><h3 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a>线程的休眠</h3><p>休眠可以让线程执行速度慢一些，休眠方法为：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sleep(<span class="keyword">long</span> <span class="built_in">millis</span>) <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure></p><p>设置休眠单位是ms</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>线程优先级的操作方法</p><ul><li>public static final int MAX_PRIORITY            常量      最高优先级，10</li><li>public static final int NORM_PRIORITY           常量      中等优先级，5</li><li>public static final int MIN_PRIORITY            常量      最低优先级，1</li><li>public final void setPriority(int newPriority)  普通方法  设置线程优先级</li><li>public final int getPriority()                  普通方法  取得线程优先级</li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p><strong>一个代码块中多个操作在同一个时间内只有一个线程进行，其他线程要等待此线程完成后才可以继续执行</strong></p><ul><li>同步代码块：利用<strong>Synchronized</strong>包装代码块，需要制定同步对象，一般为this</li><li>同步方法：利用<strong>synchronized</strong>定义方法</li></ul><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>同步指的是，一个线程等待另外一个线程执行完毕才会继续执行的形式，而死锁指的是，两个线程都在等待彼此完成，造成了程序的停滞状态</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程：程序的一次动态执行的过程，从代码加载到执行完毕的一整个过程。&lt;br&gt;线程：线程是比进程更小的一个单位，线程是在进程的基础上进一步进行划分，一个进程可以分为多个线程，这些线程同时存在同时运行。&lt;br&gt;多进程：多进程的操作系统可以同时运行多个程序，由于CPU具备分时机制，每个进程都可以循环获得自己的CPU时间，使进程看起来像同时进行一样。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>IO编程</title>
    <link href="https://xxyxt.github.io/2019/02/25/Java-IO%E7%BC%96%E7%A8%8B/"/>
    <id>https://xxyxt.github.io/2019/02/25/Java-IO编程/</id>
    <published>2019-02-25T02:33:25.566Z</published>
    <updated>2019-02-25T03:46:34.906Z</updated>
    
    <content type="html"><![CDATA[<p>所有的IO操作都在java.io包中进行定义，一共包含5个类和一个接口：</p><ul><li>五个类：File、InputStream、OutputStream、Reader、Writer</li><li>一个接口：Serializable</li></ul><a id="more"></a><h2 id="文件操作类：File"><a href="#文件操作类：File" class="headerlink" title="文件操作类：File"></a>文件操作类：File</h2><h3 id="File类常用方法"><a href="#File类常用方法" class="headerlink" title="File类常用方法"></a>File类常用方法</h3><ul><li>public File(String pathname) 构造方法 传递完整的文件操作路径</li><li>public File(File parent,String child) 构造方法 设置父路径和子文件路径</li><li>public boolean creatNewFile() throws IOException 普通 创建新文件</li><li>public boolean exists() 普通方法 判断给定的路径是否存在</li><li>pblic boolean delete() 普通方法 删除指定路径的文件</li><li>public File getParentFile() 普通方法 取得当前路径的父路径</li><li>public boolean mkdirs() 普通方法 创建多级目录</li><li>public long length() 普通方法 取得文件大小，以字节为单位返回</li><li>public boolean isFile() 普通方法 判断给定路径是否是文件</li><li>public boolean isDirectory() 普通方法 判断给定路径是否是目录</li><li>public long lastModified() 普通方法 取得最后一次修改日期时间</li><li>public String[] list() 普通方法 取得指定目录的所有内容</li><li>public File[] listFiles() 普通方法 列出所有路径以File类包含</li></ul><h2 id="字节输出流：OutputStream"><a href="#字节输出流：OutputStream" class="headerlink" title="字节输出流：OutputStream"></a>字节输出流：OutputStream</h2><p><strong>定义：</strong>public abstract class OutputStream extends Object implements Closeable,Flushable</p><h3 id="OutputStream类常用方法"><a href="#OutputStream类常用方法" class="headerlink" title="OutputStream类常用方法"></a>OutputStream类常用方法</h3><ul><li>public void close() throws IOException 普通方法 关闭字节输出流</li><li>public void flush() throws IOException 普通方法 强制刷新</li><li>public abstract void write(int b) throws IOException 普通方法 输出单个字节</li><li>public void write(byte[] b) throws IOException 普通方法 输出全部字节数组数据</li><li>public void write(byte[] b，int off,int len) throws IOException 普通方法 输出部分字节数组数据</li></ul><p>OutputStream是一个抽象类,需要使用FileOutputStream子类完成操作</p><h3 id="FileOutputStream常用方法"><a href="#FileOutputStream常用方法" class="headerlink" title="FileOutputStream常用方法"></a>FileOutputStream常用方法</h3><ul><li>public FileOutputStream(File file) throws FileNotFoundException 构造方法 将内容输出到指定路径，如果文件存在，则覆盖</li><li>public FileOutputStream(File file，boolean append) throws FileNotFoundException 构造方法 布尔参数设置为true，则表示追加</li></ul><h2 id="字节输入流：InputStream"><a href="#字节输入流：InputStream" class="headerlink" title="字节输入流：InputStream"></a>字节输入流：InputStream</h2><p><strong>定义：</strong>public abstract class OutputStream extends Object implements Closeable</p><h3 id="InputStream类常用方法"><a href="#InputStream类常用方法" class="headerlink" title="InputStream类常用方法"></a>InputStream类常用方法</h3><ul><li>public void close() throws IOException 普通方法 关闭字节输入流</li><li>public abstract int read() throws IOException 普通方法 读取单个字节</li><li>public int read(byte[] b) throws IOException 普通方法 将数据读取到字节数组中，同时返回读取长度</li><li>public int read(byte[] b，int off,int len) throws IOException 普通方法 将数据读取到部分字节数组中，同时返回读取长度</li></ul><p>InputStream是一个抽象类,需要使用FileInputStream子类完成操作</p><h3 id="FileInputStream常用方法"><a href="#FileInputStream常用方法" class="headerlink" title="FileInputStream常用方法"></a>FileInputStream常用方法</h3><ul><li>public FileInputStream(File file) throws FileNotFoundException 构造方法 设置要读取文件的路径</li></ul><h2 id="字符输出流：Writer"><a href="#字符输出流：Writer" class="headerlink" title="字符输出流：Writer"></a>字符输出流：Writer</h2><p><strong>定义：</strong>public abstract class Writer extends Object implements Appendable,Closeable,Flushable</p><p>利用Writer类可以实现字符数组(包含字符串)的输出</p><h3 id="Writer类常用方法"><a href="#Writer类常用方法" class="headerlink" title="Writer类常用方法"></a>Writer类常用方法</h3><ul><li>public void close() throws IOException 普通方法 关闭字节输出流</li><li>public void flush() throws IOException 普通方法 强制刷新</li><li>public Writer append(CharSequence csq) throws IOException 普通方法 追加数据</li><li>public void write(String str) throws IOException 普通方法 输出字符串数据</li><li>public void write(char[] cbuf) throws IOException 普通方法 输出字符数组数据</li></ul><p>Writer是一个抽象类,需要使用FileWriter子类完成操作</p><h3 id="FileWriter常用方法"><a href="#FileWriter常用方法" class="headerlink" title="FileWriter常用方法"></a>FileWriter常用方法</h3><ul><li>public FileWriter(File file) throws FileNotFoundException 构造方法 设置输出文件</li><li>public FileWriter(File file，boolean append) throws FileNotFoundException 构造方法 设置输出文件是否以追加方式进行数据追加</li></ul><h2 id="字符输出流：Reader"><a href="#字符输出流：Reader" class="headerlink" title="字符输出流：Reader"></a>字符输出流：Reader</h2><p><strong>定义：</strong>public abstract class Reader extends Object implements Readable,Closeable</p><h3 id="Reader类常用方法"><a href="#Reader类常用方法" class="headerlink" title="Reader类常用方法"></a>Reader类常用方法</h3><ul><li>public void close() throws IOException 普通方法 关闭字节输入流</li><li>public int read() throws IOException 普通方法 读取单个数据</li><li>public int read(char[] cbuf) throws IOException 普通方法 读取数据到字符数组，返回读取长度</li></ul><p>Reader是一个抽象类,需要使用FileReader子类完成操作</p><h3 id="FileWriter常用方法-1"><a href="#FileWriter常用方法-1" class="headerlink" title="FileWriter常用方法"></a>FileWriter常用方法</h3><ul><li>publicFileReader(File file) throws FileNotFoundException 构造方法 设置要读取的文件路径</li></ul><h2 id="案例：文件复制"><a href="#案例：文件复制" class="headerlink" title="案例：文件复制"></a>案例：文件复制</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package Test;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">public</span> class testDemo13 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) throws Exception&#123;</span><br><span class="line"><span class="keyword">long</span> star=System.currentTimeMillis();</span><br><span class="line"><span class="built_in">if</span>(args.length!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"参数输入错误"</span>);</span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">File</span> filein=<span class="keyword">new</span> <span class="built_in">File</span>(args[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">if</span>(!filein.<span class="built_in">exists</span>())</span><br><span class="line">&#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"原文件不存在"</span>);</span><br><span class="line">System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">File</span> fileout=<span class="keyword">new</span> <span class="built_in">File</span>(args[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">if</span>(!fileout.getParentFile().<span class="built_in">exists</span>())</span><br><span class="line">&#123;</span><br><span class="line">fileout.getParentFile().mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">InputStream input=<span class="keyword">new</span> FileInputStream(filein);</span><br><span class="line">OutputStream output=<span class="keyword">new</span> FileOutputStream(fileout);</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">byte</span> data[]=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">while</span>((temp=input.<span class="built_in">read</span>(data))!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">output.<span class="built_in">write</span>(data,<span class="number">0</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line">input.<span class="built_in">close</span>();</span><br><span class="line">output.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">long</span> <span class="built_in">end</span>=System.currentTimeMillis();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"复制所花费的时间:"</span>+(<span class="built_in">end</span>-star));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有的IO操作都在java.io包中进行定义，一共包含5个类和一个接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;五个类：File、InputStream、OutputStream、Reader、Writer&lt;/li&gt;
&lt;li&gt;一个接口：Serializable&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://xxyxt.github.io/2019/02/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://xxyxt.github.io/2019/02/08/正则表达式/</id>
    <published>2019-02-08T12:11:30.460Z</published>
    <updated>2019-02-25T03:46:59.344Z</updated>
    
    <content type="html"><![CDATA[<p>所有的正则表达式的类都定义在java.util.regex包里面。此包中主要定义了两个主要的类：</p><ul><li>Pattern类：主要定义要使用的表达式对象</li><li>Macher类：用于进行正则标记与指定内容的匹配操作</li></ul><a id="more"></a><p>常用的标记主要有6类：</p><ol><li><p>单个字符(数量：1)</p><ul><li>字符：表示由一位字符组成</li><li>\：表示转义字符”\”</li><li>\t：表示一个制表符</li><li>\n：表示一个换行符</li></ul></li><li><p>字符集(数量：1)</p><ul><li>[abc]：表示可能是字符a,b,c中的任意一位</li><li>[^abc]：表示不是字符a,b,c中的任意一位</li><li>[a-z]：表示所有的小写字母</li><li>[a-zA-Z]：表示任意一位字符不区分大小写</li><li>[0-9]：表示任意一位数字</li></ul></li><li><p>简化的字符集表达式(数量：1)</p><ul><li>.：表示任意一位字符</li><li>\d：等价于”[0-9]”,属于简化写法</li><li>\D：等价于”[^0-9]”,属于简化写法</li><li>\s：表示任意的空白字符，如”\t”,”\n”等</li><li>\S：表示任意的非空白字符</li><li>\w：等价于”[a-zA-Z_0-9]”,表示由任意的数字、字母、下划线组成</li><li>\W：等价于”[^a-zA-Z_0-9]”,表示不是由任意的数字、字母、下划线组成</li></ul></li><li><p>边界匹配</p><ul><li>^：正则的开始</li><li>$：正则的结束</li></ul></li><li><p>数量表达</p><ul><li>正则?：表示正则可以出现1次或0次</li><li>正则+：表示正则可以出现1次或者1次以上</li><li>正则*：表示正则可以出现0次、1次或多次</li><li>正则{n}：表示正则正好出现n次</li><li>正则{n,}：表示正则出现n次以上(包含n次)</li><li>正则{n,m}：表示此正则出现n~m次</li></ul></li><li><p>逻辑运算</p><ul><li>正则1正则2：正则1判断完成后继续判断正则2</li><li>正则1 | 正则2：正则1或者是正则2有一组满足即可</li><li>(正则)：将多个正则设置为1组，可以为这一组单独设置出现的次数</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有的正则表达式的类都定义在java.util.regex包里面。此包中主要定义了两个主要的类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pattern类：主要定义要使用的表达式对象&lt;/li&gt;
&lt;li&gt;Macher类：用于进行正则标记与指定内容的匹配操作&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>内建函数式接口</title>
    <link href="https://xxyxt.github.io/2019/02/02/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>https://xxyxt.github.io/2019/02/02/内建函数式接口/</id>
    <published>2019-02-02T14:43:02.451Z</published>
    <updated>2019-02-02T15:03:38.476Z</updated>
    
    <content type="html"><![CDATA[<p>从JDK 1.8开始提供了一个新的开发包：java.util.function，并在这个包中提供了4个核心的函数式接口<br><a id="more"></a></p><ol><li><p>功能型接口(Function)</p><ul><li><p>接口定义如下 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主要作用：此接口需要接收一个参数，并且返回一个处理结果</p></li></ul></li></ol><ol start="2"><li><p>消费型接口(Consumer)</p><ul><li><p>接口定义如下 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主要作用：此接口需要接收一个参数，不返回处理结果</p></li></ul></li><li><p>供给型接口(Supplier)</p><ul><li><p>接口定义如下 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主要作用：此接不接收参数，可以返回处理结果</p></li></ul></li><li><p>断言型接口(Predicate)</p><ul><li><p>接口定义如下 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主要作用：进行判断操作</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从JDK 1.8开始提供了一个新的开发包：java.util.function，并在这个包中提供了4个核心的函数式接口&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>比较器：Comparable &amp;&amp; 挽救的比较器：Comparator</title>
    <link href="https://xxyxt.github.io/2019/02/02/%E6%AF%94%E8%BE%83%E5%99%A8%EF%BC%9AComparable/"/>
    <id>https://xxyxt.github.io/2019/02/02/比较器：Comparable/</id>
    <published>2019-02-02T14:10:22.307Z</published>
    <updated>2019-02-28T07:44:56.447Z</updated>
    
    <content type="html"><![CDATA[<p>普通数组可以直接使用Arrays.sort()方法根据数据的大小关系进行排序，对象数据存储的是地址，不能直接依据大小关系进行排序，Arrays类中重载了sort方法，可以实现对象数组的排序。</p><p>前提条件是：<strong>对象所在的类一定要实现Comparable接口</strong></p><a id="more"></a><h2 id="比较器：Comparable"><a href="#比较器：Comparable" class="headerlink" title="比较器：Comparable"></a>比较器：Comparable</h2><p>接口定义如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Comparable&lt;T&gt;&#123;</span><br><span class="line">public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此接口只定义了一个方法，返回int型数值，用户覆写此方法只需要返回3种结果：1，-1,0</p><p><strong>String类，Integer类都实现了Comparable接口</strong></p><p>实现对象数组的排序</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">class Human implements Comparable&lt;Human&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> <span class="built_in">height</span>;</span><br><span class="line"><span class="keyword">public</span> Human(<span class="keyword">String</span> name,<span class="keyword">double</span> <span class="built_in">height</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.<span class="built_in">height</span>=<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> toString()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"名字+："</span>+<span class="keyword">this</span>.name+<span class="string">",价格："</span>+<span class="keyword">this</span>.<span class="built_in">height</span>+<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> compareTo(Human h) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.<span class="built_in">height</span>&lt;h.<span class="built_in">height</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.<span class="built_in">height</span>&gt;h.<span class="built_in">height</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class testDemo3 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Human hu[]=<span class="keyword">new</span> Human[] &#123;</span><br><span class="line"><span class="keyword">new</span> Human(<span class="string">"1"</span>,<span class="number">1.65</span>),</span><br><span class="line"><span class="keyword">new</span> Human(<span class="string">"2"</span>,<span class="number">1.75</span>),</span><br><span class="line"><span class="keyword">new</span> Human(<span class="string">"3"</span>,<span class="number">1.68</span>),</span><br><span class="line"><span class="keyword">new</span> Human(<span class="string">"4"</span>,<span class="number">1.85</span>),</span><br><span class="line"><span class="keyword">new</span> Human(<span class="string">"5"</span>,<span class="number">1.70</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.<span class="built_in">sort</span>(hu);</span><br><span class="line">System.out.<span class="built_in">println</span>(Arrays.toString(hu));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="挽救的比较器：Comparator"><a href="#挽救的比较器：Comparator" class="headerlink" title="挽救的比较器：Comparator"></a>挽救的比较器：Comparator</h2><p>利用Compara比较器，需要事先考虑好排序的需求，如果事先没有考虑好需要排序，没有实现Comparable接口，后期又需要排序，可以使用另外一种比较器：Comparator。<br>接口的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T <span class="number">01</span>,T o2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果利用Comparator接口实现对象数组的排序操作，需要更换java.util.Arrays类中的排序方法。<br><strong>public static <t> void sort(T[] a,Comparator&lt;? super T&gt; c)</t></strong><br>利用Comparator接口实现对象数组的排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test1;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String name,<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"手机名："</span>+<span class="keyword">this</span>.name+<span class="string">"，手机价格："</span>+<span class="keyword">this</span>.price+<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneComparator</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Comparator</span>&lt;<span class="title">Phone</span>&gt;</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Phone p1,Phone p2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p1.getPrice()&gt;p2.getPrice()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p1.getPrice()&lt;p2.getPrice()) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo16</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Phone P[]=<span class="keyword">new</span> Phone[] &#123;</span><br><span class="line"><span class="keyword">new</span> Phone(<span class="string">"apple"</span>,<span class="number">8999</span>),</span><br><span class="line"><span class="keyword">new</span> Phone(<span class="string">"HUAWEU"</span>,<span class="number">19999</span>)</span><br><span class="line">&#125;;</span><br><span class="line">java.util.Arrays.sort(P,<span class="keyword">new</span> PhoneComparator());</span><br><span class="line">System.out.println(java.util.Arrays.toString(P));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;普通数组可以直接使用Arrays.sort()方法根据数据的大小关系进行排序，对象数据存储的是地址，不能直接依据大小关系进行排序，Arrays类中重载了sort方法，可以实现对象数组的排序。&lt;/p&gt;
&lt;p&gt;前提条件是：&lt;strong&gt;对象所在的类一定要实现Comparable接口&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对象克隆</title>
    <link href="https://xxyxt.github.io/2019/02/02/%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/"/>
    <id>https://xxyxt.github.io/2019/02/02/对象克隆/</id>
    <published>2019-02-02T06:40:40.152Z</published>
    <updated>2019-02-02T14:15:26.423Z</updated>
    
    <content type="html"><![CDATA[<p>在Object类中存在一个clone()方法用于对象的克隆</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportion</span>;</span><br></pre></td></tr></table></figure><p>此方法的权限是<strong>Protected</strong>,所以在不同的包中产生的对象将无法调用Object类中的clone方法，因此需要覆写，才可以完成克隆操作</p><p>并不是所有的对象都可以被克隆，为了区分哪些类对象可以被克隆，提供了一个Cloneable接口，此接口没有任何方法，只是一种标识接口</p><a id="more"></a><p>代码演示如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name,<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"名字:"</span>+<span class="keyword">this</span>.name+<span class="string">",价格："</span>+<span class="keyword">this</span>.price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Book booka=<span class="keyword">new</span> Book(<span class="string">"java"</span>,<span class="number">34</span>);</span><br><span class="line">Book bookb=(Book) booka.clone();</span><br><span class="line">bookb.setName(<span class="string">"python"</span>);</span><br><span class="line">System.out.println(booka);</span><br><span class="line">System.out.println(bookb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Object类中存在一个clone()方法用于对象的克隆&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;Object &lt;span class=&quot;title&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; CloneNotSupportion&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此方法的权限是&lt;strong&gt;Protected&lt;/strong&gt;,所以在不同的包中产生的对象将无法调用Object类中的clone方法，因此需要覆写，才可以完成克隆操作&lt;/p&gt;
&lt;p&gt;并不是所有的对象都可以被克隆，为了区分哪些类对象可以被克隆，提供了一个Cloneable接口，此接口没有任何方法，只是一种标识接口&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer&amp;&amp;String</title>
    <link href="https://xxyxt.github.io/2019/01/30/StringBuffer-String/"/>
    <id>https://xxyxt.github.io/2019/01/30/StringBuffer-String/</id>
    <published>2019-01-30T08:48:43.334Z</published>
    <updated>2019-01-30T09:09:51.720Z</updated>
    
    <content type="html"><![CDATA[<p>字符串一般使用String进行表示，一旦声明，字符串常量就不可能改变。而字符串对象可以改变，但是只是改变其内存地址的指向。<br>如果想要频繁修改字符串，可以使用StringBuffer类，StringBuffer类通过append()方法，进行数据的连接。</p><a id="more"></a><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>public final class String extends Object implements Serializable,Comparable<string>，CharSequence</string></p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>public final class String extends Object implementss Serializable,CharSequence</p><ul><li>[] 可以发现String和StringBuffer类都是 CharSequence接口的子类，因此都可以向上转型为 CharSequence接口</li></ul><h2 id="String类转化为StringBuffer类"><a href="#String类转化为StringBuffer类" class="headerlink" title="String类转化为StringBuffer类"></a>String类转化为StringBuffer类</h2><ul><li>利用StringBuffer类的构造方法</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDemo2</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"Hello world"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用StringBuffer类的append()方法</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDemo2</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">buf.append(<span class="string">"hello world"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuffer类转化为String类"><a href="#StringBuffer类转化为String类" class="headerlink" title="StringBuffer类转化为String类"></a>StringBuffer类转化为String类</h2><ul><li>利用toString()方法可以将StringBuffer类转换为String</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"><span class="keyword">public</span> class testDemo2 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=buf.toString();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用String构造方法 </li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"><span class="keyword">public</span> class testDemo2 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=<span class="keyword">new</span> <span class="keyword">String</span>(buf);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String和StringBuffer的比较"><a href="#String和StringBuffer的比较" class="headerlink" title="String和StringBuffer的比较"></a>String和StringBuffer的比较</h2><p>String类提供了一个方法用于比较String和StringBuffer的字符串的内容<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> contentEquals(StringBuffer buf)</span><br></pre></td></tr></table></figure></p><p><strong>注意：此方法比较会区分大小写</strong></p><h2 id="StringBuffe常用方法"><a href="#StringBuffe常用方法" class="headerlink" title="StringBuffe常用方法"></a>StringBuffe常用方法</h2><ul><li>public StringBuffer append()  追加数据</li><li>public StringBuffer reverse() 字符串翻转</li><li>public StringBuffer insert(int offset,数据类型 变量) 指定位置追加内容</li><li>public StringBuffer delete(int star,int end)  指定删除索引范围的内容</li></ul><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><ul><li>结构如下<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> StringBuilder <span class="keyword">extends</span> Object <span class="keyword">implements</span> Serializable,CharSequence</span><br></pre></td></tr></table></figure></li></ul><p> 结构定义和StringBuffer完全相同，但是StringBuffer类的定义全部使用<strong>synchronized</strong>进行同步定义，属于安全的线程操作，而StringBuilder类的方法都是异步方法，属于非线程安全操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串一般使用String进行表示，一旦声明，字符串常量就不可能改变。而字符串对象可以改变，但是只是改变其内存地址的指向。&lt;br&gt;如果想要频繁修改字符串，可以使用StringBuffer类，StringBuffer类通过append()方法，进行数据的连接。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://xxyxt.github.io/2019/01/21/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://xxyxt.github.io/2019/01/21/单例设计模式/</id>
    <published>2019-01-21T02:48:33.235Z</published>
    <updated>2019-01-21T02:56:09.265Z</updated>
    
    <content type="html"><![CDATA[<p>单例设计模式：单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。</p><a id="more"></a><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>需要：</p><ul><li><p>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</p></li><li><p>在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。</p></li><li><p>定义一个静态方法返回这个唯一对象。</p></li></ul><h3 id="实现一：立即加载-“饿汉模式”"><a href="#实现一：立即加载-“饿汉模式”" class="headerlink" title="实现一：立即加载 / “饿汉模式”"></a>实现一：立即加载 / “饿汉模式”</h3><p>立即加载就是使用类的时候已经将对象创建完毕（不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故又被称为“饿汉模式”），常见的实现办法就是直接new实例化。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static、final修饰</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span><span class="keyword"> final</span> Singleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">   <span class="keyword"> private</span> Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>“饿汉模式”的优缺点：</p><ul><li><p>优点：实现起来简单，没有多线程同步问题。</p></li><li><p>缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。</p></li></ul><h3 id="实现二：延迟加载-“懒汉模式”"><a href="#实现二：延迟加载-“懒汉模式”" class="headerlink" title="实现二：延迟加载 / “懒汉模式”"></a>实现二：延迟加载 / “懒汉模式”</h3><p>延迟加载就是调用get()方法时实例才被创建（先不急着实例化出对象，等要用的时候才给你创建出来。不着急，故又称为“懒汉模式”），常见的实现方法就是在get方法中进行new实例化。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“懒汉模式”的优缺点：</p><ul><li><p>优点：实现起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存。</p></li><li><p>缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态。</p></li></ul><h3 id="实现三：线程安全的“懒汉模式”"><a href="#实现三：线程安全的“懒汉模式”" class="headerlink" title="实现三：线程安全的“懒汉模式”"></a>实现三：线程安全的“懒汉模式”</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例，加synchronized关键字实现同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优点：在多线程情形下，保证了“懒汉模式”的线程安全。</p></li><li><p>缺点：众所周知在多线程情形下，synchronized方法通常效率低，显然这不是最佳的实现方案。</p></li></ul><h3 id="实现四：DCL双检查锁机制（DCL：double-checked-locking）"><a href="#实现四：DCL双检查锁机制（DCL：double-checked-locking）" class="headerlink" title="实现四：DCL双检查锁机制（DCL：double checked locking）"></a>实现四：DCL双检查锁机制（DCL：double checked locking）</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查instance是否被实例化出来，如果没有进入if块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才最终实例出对象</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四算是单例模式的最佳实现方式。内存占用率高，效率高，线程安全，多线程操作原子性。</p><p><a href="https://www.cnblogs.com/binaway/p/8889184.html" target="_blank" rel="noopener">转自</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例设计模式：单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
