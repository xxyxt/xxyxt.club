<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>下雪不下雨的个人博客</title>
  
  <subtitle>to be a learner</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xxyxt.github.io/"/>
  <updated>2019-01-30T09:09:51.720Z</updated>
  <id>https://xxyxt.github.io/</id>
  
  <author>
    <name>xxyxt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>StringBuffer&amp;&amp;String</title>
    <link href="https://xxyxt.github.io/2019/01/30/StringBuffer-String/"/>
    <id>https://xxyxt.github.io/2019/01/30/StringBuffer-String/</id>
    <published>2019-01-30T08:48:43.334Z</published>
    <updated>2019-01-30T09:09:51.720Z</updated>
    
    <content type="html"><![CDATA[<p>字符串一般使用String进行表示，一旦声明，字符串常量就不可能改变。而字符串对象可以改变，但是只是改变其内存地址的指向。<br>如果想要频繁修改字符串，可以使用StringBuffer类，StringBuffer类通过append()方法，进行数据的连接。</p><a id="more"></a><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>public final class String extends Object implements Serializable,Comparable<string>，CharSequence</string></p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>public final class String extends Object implementss Serializable,CharSequence</p><ul><li>[] 可以发现String和StringBuffer类都是 CharSequence接口的子类，因此都可以向上转型为 CharSequence接口</li></ul><h2 id="String类转化为StringBuffer类"><a href="#String类转化为StringBuffer类" class="headerlink" title="String类转化为StringBuffer类"></a>String类转化为StringBuffer类</h2><ul><li>利用StringBuffer类的构造方法</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDemo2</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"Hello world"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用StringBuffer类的append()方法</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDemo2</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">buf.append(<span class="string">"hello world"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuffer类转化为String类"><a href="#StringBuffer类转化为String类" class="headerlink" title="StringBuffer类转化为String类"></a>StringBuffer类转化为String类</h2><ul><li>利用toString()方法可以将StringBuffer类转换为String</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"><span class="keyword">public</span> class testDemo2 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=buf.toString();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用String构造方法 </li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"><span class="keyword">public</span> class testDemo2 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=<span class="keyword">new</span> <span class="keyword">String</span>(buf);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String和StringBuffer的比较"><a href="#String和StringBuffer的比较" class="headerlink" title="String和StringBuffer的比较"></a>String和StringBuffer的比较</h2><p>String类提供了一个方法用于比较String和StringBuffer的字符串的内容<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> contentEquals(StringBuffer buf)</span><br></pre></td></tr></table></figure></p><p><strong>注意：此方法比较会区分大小写</strong></p><h2 id="StringBuffe常用方法"><a href="#StringBuffe常用方法" class="headerlink" title="StringBuffe常用方法"></a>StringBuffe常用方法</h2><ul><li>public StringBuffer append()  追加数据</li><li>public StringBuffer reverse() 字符串翻转</li><li>public StringBuffer insert(int offset,数据类型 变量) 指定位置追加内容</li><li>public StringBuffer delete(int star,int end)  指定删除索引范围的内容</li></ul><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><ul><li>结构如下<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> StringBuilder <span class="keyword">extends</span> Object <span class="keyword">implements</span> Serializable,CharSequence</span><br></pre></td></tr></table></figure></li></ul><p> 结构定义和StringBuffer完全相同，但是StringBuffer类的定义全部使用<strong>synchronized</strong>进行同步定义，属于安全的线程操作，而StringBuilder类的方法都是异步方法，属于非线程安全操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串一般使用String进行表示，一旦声明，字符串常量就不可能改变。而字符串对象可以改变，但是只是改变其内存地址的指向。&lt;br&gt;如果想要频繁修改字符串，可以使用StringBuffer类，StringBuffer类通过append()方法，进行数据的连接。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://xxyxt.github.io/2019/01/21/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://xxyxt.github.io/2019/01/21/单例设计模式/</id>
    <published>2019-01-21T02:48:33.235Z</published>
    <updated>2019-01-21T02:56:09.265Z</updated>
    
    <content type="html"><![CDATA[<p>单例设计模式：单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。</p><a id="more"></a><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>需要：</p><ul><li><p>将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。</p></li><li><p>在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。</p></li><li><p>定义一个静态方法返回这个唯一对象。</p></li></ul><h3 id="实现一：立即加载-“饿汉模式”"><a href="#实现一：立即加载-“饿汉模式”" class="headerlink" title="实现一：立即加载 / “饿汉模式”"></a>实现一：立即加载 / “饿汉模式”</h3><p>立即加载就是使用类的时候已经将对象创建完毕（不管以后会不会使用到该实例化对象，先创建了再说。很着急的样子，故又被称为“饿汉模式”），常见的实现办法就是直接new实例化。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 将自身实例化对象设置为一个属性，并用static、final修饰</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span><span class="keyword"> final</span> Singleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line">    </span><br><span class="line">    // 构造方法私有化</span><br><span class="line">   <span class="keyword"> private</span> Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 静态方法返回该实例</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>“饿汉模式”的优缺点：</p><ul><li><p>优点：实现起来简单，没有多线程同步问题。</p></li><li><p>缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。</p></li></ul><h3 id="实现二：延迟加载-“懒汉模式”"><a href="#实现二：延迟加载-“懒汉模式”" class="headerlink" title="实现二：延迟加载 / “懒汉模式”"></a>实现二：延迟加载 / “懒汉模式”</h3><p>延迟加载就是调用get()方法时实例才被创建（先不急着实例化出对象，等要用的时候才给你创建出来。不着急，故又称为“懒汉模式”），常见的实现方法就是在get方法中进行new实例化。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“懒汉模式”的优缺点：</p><ul><li><p>优点：实现起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存。</p></li><li><p>缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态。</p></li></ul><h3 id="实现三：线程安全的“懒汉模式”"><a href="#实现三：线程安全的“懒汉模式”" class="headerlink" title="实现三：线程安全的“懒汉模式”"></a>实现三：线程安全的“懒汉模式”</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例，加synchronized关键字实现同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优点：在多线程情形下，保证了“懒汉模式”的线程安全。</p></li><li><p>缺点：众所周知在多线程情形下，synchronized方法通常效率低，显然这不是最佳的实现方案。</p></li></ul><h3 id="实现四：DCL双检查锁机制（DCL：double-checked-locking）"><a href="#实现四：DCL双检查锁机制（DCL：double-checked-locking）" class="headerlink" title="实现四：DCL双检查锁机制（DCL：double checked locking）"></a>实现四：DCL双检查锁机制（DCL：double checked locking）</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查instance是否被实例化出来，如果没有进入if块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才最终实例出对象</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四算是单例模式的最佳实现方式。内存占用率高，效率高，线程安全，多线程操作原子性。</p><p><a href="https://www.cnblogs.com/binaway/p/8889184.html" target="_blank" rel="noopener">转自</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例设计模式：单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>通配符</title>
    <link href="https://xxyxt.github.io/2019/01/20/%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <id>https://xxyxt.github.io/2019/01/20/通配符/</id>
    <published>2019-01-20T14:37:15.444Z</published>
    <updated>2019-01-20T14:58:26.499Z</updated>
    
    <content type="html"><![CDATA[<p>泛型技术解决了向下转型的安全性问题，随之而来，又会产生一个新的问题：如果泛型类设置的不同，方法里面的参数引用也必定是不同的，为了解决这个问题，引入了通配符的使用</p><a id="more"></a><p>如果没有通配符，在泛型方法里面定义多个泛型类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> T msg;</span><br><span class="line"><span class="keyword">public</span> void setMsg(msg) &#123;</span><br><span class="line"><span class="keyword">this</span>.msg=msg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T getMsg() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo7</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> static void main(String args[]) &#123;</span><br><span class="line">Message&lt;String&gt; m=new Message&lt;&gt;();</span><br><span class="line">m.<span class="keyword">set</span>(<span class="string">"Hello"</span>);</span><br><span class="line">Message&lt;Integer&gt; n=new Message&lt;&gt;();</span><br><span class="line">n.<span class="keyword">set</span>(<span class="number">19</span>);</span><br><span class="line">fu(m);</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> static void <span class="function"><span class="title">fun</span><span class="params">(Message&lt;String&gt; m)</span></span> &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(m.getMsg());</span><br><span class="line">ystem.<span class="keyword">out</span>.println(n.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样程序显然会报错</p><p>可以使用通配符”?”解决参数的传递问题，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> T msg;</span><br><span class="line"><span class="keyword">public</span> void setMsg(T msg) &#123;</span><br><span class="line"><span class="keyword">this</span>.msg=msg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T getMsg() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo7</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> static void main(String args[]) &#123;</span><br><span class="line">Message&lt;String&gt; m=new Message&lt;&gt;();</span><br><span class="line">m.setMsg(<span class="string">"Hello"</span>);</span><br><span class="line">Message&lt;Integer&gt; n=new Message&lt;&gt;();</span><br><span class="line">n.setMsg(<span class="number">19</span>);</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> static void <span class="function"><span class="title">fun</span><span class="params">(Message&lt;?&gt; m)</span></span> &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(m.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用通配符”?”，不管何种泛型类型，fun方法对抗与接收参数</strong></p><p>在”?”通配符的基础上还有两个子通配符：</p><ul><li><p>“？ extends 类”，eg:？ extends Number: 意味着可以设置Number或者Number的子类</p></li><li><p>“？ super 类”，eg：? super String: 只能设置String和他的父类Object</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泛型技术解决了向下转型的安全性问题，随之而来，又会产生一个新的问题：如果泛型类设置的不同，方法里面的参数引用也必定是不同的，为了解决这个问题，引入了通配符的使用&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="https://xxyxt.github.io/2019/01/20/%E6%B3%9B%E5%9E%8B/"/>
    <id>https://xxyxt.github.io/2019/01/20/泛型/</id>
    <published>2019-01-20T14:15:06.502Z</published>
    <updated>2019-01-21T02:19:29.995Z</updated>
    
    <content type="html"><![CDATA[<p>利用对象的多态性，可以解决方法参数统一的问题，但是随之而来的就是另外一个问题：并不是所有的向下转型都是安全的。从JDK 1.5开始提供了泛型技术，可以有效的解决这一问题</p><a id="more"></a><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>如果要开发一套地理信息系统，必定存在描述精度和纬度的数据，可以有三种数据类型：</p><ul><li>整型</li><li>浮点型</li><li>字符串</li></ul><p>相应的，如果要统一参数类型，就会存在三种转型关系：</p><ul><li>int型自动封装成Integer，向上转型为Object,Object向下转型为Integer，Integer拆封成int</li><li>double-&gt;Double&gt;Objec, Object-&gt;Double-&gt;double-</li><li>String-&gt;Object,Object-&gt;String</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;T&gt;&#123;</span></span><br><span class="line"><span class="keyword">private</span> T x;</span><br><span class="line"><span class="keyword">private</span> T y;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(T y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.y=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo7</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型是字符型</span></span><br><span class="line">Point&lt;String&gt; p=<span class="keyword">new</span> Point&lt;&gt;();</span><br><span class="line">p.setX(<span class="string">"东经 120"</span>);</span><br><span class="line">p.setY(<span class="string">"北纬 50"</span>);</span><br><span class="line">String x=p.getX();   <span class="comment">//自动拆箱</span></span><br><span class="line">String y=p.getY();   <span class="comment">//自动拆箱</span></span><br><span class="line">System.out.println(<span class="string">"经度："</span>+x+<span class="string">",维度："</span>+y);</span><br><span class="line"><span class="comment">//引用类型是整型</span></span><br><span class="line">Point&lt;Integer&gt; p1=<span class="keyword">new</span> Point&lt;&gt;();</span><br><span class="line">p1.setX(<span class="number">120</span>);</span><br><span class="line">p1.setY(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">int</span> x1=p1.getX();    <span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> y1=p1.getY();    <span class="comment">//自动拆箱</span></span><br><span class="line">System.out.println(<span class="string">"经度："</span>+x1+<span class="string">",维度："</span>+y1);</span><br><span class="line"><span class="comment">//引用类型是浮点型</span></span><br><span class="line">Point&lt;Double&gt; p2=<span class="keyword">new</span> Point&lt;&gt;();</span><br><span class="line">p2.setX(<span class="number">120.5</span>);</span><br><span class="line">p2.setY(<span class="number">50.0</span>);</span><br><span class="line"><span class="keyword">double</span> x2=p2.getX();  <span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">double</span> y2=p2.getY();  <span class="comment">//自动拆箱</span></span><br><span class="line">System.out.println(<span class="string">"经度："</span>+x2+<span class="string">",维度："</span>+y2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型后，类中的属性都是动态设置的，从而避免了向下转型的不安全性。<br>能够采用泛型的只能够是引用类型，不能是基本类型</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>除了类可以设置泛型，接口也可以设置泛型</p><p>在子类继续设置泛型标记，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Message</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">SonMessage</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Message</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(S t)</span> </span>&#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo7</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Message&lt;String&gt; m=<span class="keyword">new</span> SonMessage&lt;&gt;();</span><br><span class="line">m.print(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以在子类中不设置泛型，可以明确定义一个泛型类型，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Message</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonMessage</span> <span class="keyword">implements</span> <span class="title">Message</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo7</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Message&lt;String&gt; m=<span class="keyword">new</span> SonMessage();</span><br><span class="line">m.print(<span class="string">"helloWorld"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo7</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> static void main(String args[]) &#123;</span><br><span class="line">String str=<span class="function"><span class="title">fun</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> static &lt;T&gt; T <span class="function"><span class="title">fun</span><span class="params">(T t)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用对象的多态性，可以解决方法参数统一的问题，但是随之而来的就是另外一个问题：并不是所有的向下转型都是安全的。从JDK 1.5开始提供了泛型技术，可以有效的解决这一问题&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>foreach循环</title>
    <link href="https://xxyxt.github.io/2019/01/20/foreach%E5%BE%AA%E7%8E%AF/"/>
    <id>https://xxyxt.github.io/2019/01/20/foreach循环/</id>
    <published>2019-01-20T14:00:09.402Z</published>
    <updated>2019-01-20T14:00:22.294Z</updated>
    
    <content type="html"><![CDATA[<p>foreach循环是一种加强型的for循环，主要用于简化数组或者集合数据的输出</p><a id="more"></a><p>传统的输出代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDeno6</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line"><span class="keyword">int</span> data[]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;data.length;x++) &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(data[x] );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统的数组输出使用下标索引的方式实现数据的输出，从JDK 1.5开始for循环有了以下形式：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(数据类型 变量:数组 | 集合)</span></span>&#123;</span><br><span class="line"><span class="comment">//每次循环会将数组的内容设置给变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码如下：</span><br></pre></td></tr></table></figure></p><p>public class testDeno6 {<br>    public static void main(String args[]) {<br>        int data[]=new int[]{4,5,6,8,9};<br>        for(int x:data) {<br>            System.out.println(x );<br>        }<br>    }</p><p>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;foreach循环是一种加强型的for循环，主要用于简化数组或者集合数据的输出&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>可变参数</title>
    <link href="https://xxyxt.github.io/2019/01/20/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <id>https://xxyxt.github.io/2019/01/20/可变参数/</id>
    <published>2019-01-20T13:45:05.084Z</published>
    <updated>2019-01-20T13:51:50.243Z</updated>
    
    <content type="html"><![CDATA[<p>在调用方法时，必须按照方法定义的变量进行参数传递，但是当参数个数不确定时，就无法准确的进行方法的调用，最初的解决方法是将参数包装成一个数组,代码如下：</p><a id="more"></a><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDeno6</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span>[] data</span>)</span> &#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;data.length;x++) &#123;</span><br><span class="line">sum+=data[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，从JDK 1.5开始，在方法定义上提供了可变参数的概念，开发者可以使用<strong>参数类型…变量</strong>的形式传递若干参数，着多个变量，将以指定类型的数组进行保存，代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDeno6</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>&#125;));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">add</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">add</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span>...data</span>)</span> &#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;data.length;x++) &#123;</span><br><span class="line">sum+=data[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，即使用了可变参数定义了方法，也可以接收数组，也可以直接传递任意多个参数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在调用方法时，必须按照方法定义的变量进行参数传递，但是当参数个数不确定时，就无法准确的进行方法的调用，最初的解决方法是将参数包装成一个数组,代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaInterviewGithub</title>
    <link href="https://xxyxt.github.io/2019/01/20/java-programmer-need-know/"/>
    <id>https://xxyxt.github.io/2019/01/20/java-programmer-need-know/</id>
    <published>2019-01-20T07:48:40.000Z</published>
    <updated>2019-01-20T11:10:28.568Z</updated>
    
    <content type="html"><![CDATA[<p>　　身边的朋友或者公众号的粉丝很多人都向我询问过:“我是双非/三本/专科学校的，我有机会进入大厂吗？”、“非计算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学那些东西？”、“我该如何准备Java面试？”……这些方面的问题。我会根据自己的一点经验对大部分人关心的这些问题进行答疑解惑。现在又刚好赶上考研结束，这篇文章也算是给考研结束准备往Java后端方向发展的朋友们指名一条学习之路。道理懂了如果没有实际行动，那这篇文章对你或许没有任何意义。</p><a id="more"></a><h3 id="Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？"><a href="#Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？" class="headerlink" title="Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？"></a>Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？</h3><p>　　我自己也是非985非211学校的，结合自己的经历以及一些朋友的经历，我觉得让我回答这个问题再好不过。</p><p>　　首先，我觉得学校歧视很正常，真的太正常了，如果要抱怨的话，你只能抱怨自己没有进入名校。但是，千万不要动不动说自己学校差，动不动拿自己学校当做自己进不了大厂的借口，学历只是筛选简历的很多标准中的一个而已，如果你够优秀，简历够丰富，你也一样可以和名校同学一起同台竞争。</p><p>　　企业HR肯定是更喜欢高学历的人，毕竟985，211优秀人才比例肯定比普通学校高很多，HR团队肯定会优先在这些学校里选。这就好比相亲，你是愿意在很多优秀的人中选一个优秀的，还是愿意在很多普通的人中选一个优秀的呢？<br>　　<br>　　双非本科甚至是二本、三本甚至是专科的同学也有很多进入大厂的，不过比率相比于名校的低很多而已。从大厂招聘的结果上看，高学历人才的数量占据大头，那些成功进入BAT、美团，京东，网易等大厂的双非本科甚至是二本、三本甚至是专科的同学往往是因为具备丰富的项目经历或者在某个含金量比较高的竞赛比如ACM中取得了不错的成绩。<strong>一部分学历不突出但能力出众的面试者能够进入大厂并不是说明学历不重要，而是学历的软肋能够通过其他的优势来弥补。</strong> 所以，如果你的学校不够好而你自己又想去大厂的话，建议你可以从这几点来做：<strong>①尽量在面试前最好有一个可以拿的出手的项目；②有实习条件的话，尽早出去实习，实习经历也会是你的简历的一个亮点（有能力在大厂实习最佳！）；③参加一些含金量比较高的比赛，拿不拿得到名次没关系，重在锻炼。</strong></p><h3 id="Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？"><a href="#Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？" class="headerlink" title="Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？"></a>Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？</h3><p>　　当然可以！现在非科班的程序员很多，很大一部分原因是互联网行业的工资比较高。我们学校外面的培训班里面90%都是非科班，我觉得他们很多人学的都还不错。另外，我的一个朋友本科是机械专业，大一开始自学安卓，技术贼溜，在我看来他比大部分本科是计算机的同学学的还要好。参考Question1的回答，即使你是非科班程序员，如果你想进入大厂的话，你也可以通过自己的其他优势来弥补。</p><p>　　我觉得我们不应该因为自己的专业给自己划界限或者贴标签，说实话，很多科班的同学可能并不如你，你以为科班的同学就会认真听讲吗？还不是几乎全靠自己课下自学！不过如果你是非科班的话，你想要学好，那么注定就要舍弃自己本专业的一些学习时间，这是无可厚非的。</p><p>　　建议非科班的同学，首先要打好计算机基础知识基础：①计算机网络、②操作系统、③数据机构与算法，我个人觉得这3个对你最重要。这些东西就像是内功，对你以后的长远发展非常有用。当然，如果你想要进大厂的话，这些知识也是一定会被问到的。另外，“一定学好数据机构与算法！一定学好数据机构与算法！一定学好数据机构与算法！”，重要的东西说3遍。</p><h3 id="Question3-我没有实习经历的话找工作是不是特别艰难？"><a href="#Question3-我没有实习经历的话找工作是不是特别艰难？" class="headerlink" title="Question3: 我没有实习经历的话找工作是不是特别艰难？"></a>Question3: 我没有实习经历的话找工作是不是特别艰难？</h3><p>　　没有实习经历没关系，只要你有拿得出手的项目或者大赛经历的话，你依然有可能拿到大厂的 offer 。笔主当时找工作的时候就没有实习经历以及大赛获奖经历，单纯就是凭借自己的项目经验撑起了整个面试。</p><p>　　如果你既没有实习经历，又没有拿得出手的项目或者大赛经历的话，我觉得在简历关，除非你有其他特别的亮点，不然，你应该就会被刷。</p><h3 id="Question4-我该如何准备面试呢？面试的注意事项有哪些呢？"><a href="#Question4-我该如何准备面试呢？面试的注意事项有哪些呢？" class="headerlink" title="Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？"></a>Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？</h3><p>下面是我总结的一些准备面试的Tips以及面试必备的注意事项：</p><ol><li><strong>准备一份自己的自我介绍，面试的时候根据面试对象适当进行修改</strong>（突出重点，突出自己的优势在哪里，切忌流水账）；</li><li><strong>注意随身带上自己的成绩单和简历复印件；</strong> （有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。）</li><li><strong>如果需要笔试就提前刷一些笔试题，大部分在线笔试的类型是选择题+编程题，有的还会有简答题。</strong>（平时空闲时间多的可以刷一下笔试题目（牛客网上有很多），但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。）另外，注意抓重点，因为题目太多了，但是有很多题目几乎次次遇到，像这样的题目一定要搞定。</li><li><strong>提前准备技术面试。</strong> 搞清楚自己面试中可能涉及哪些知识点、那些知识点是重点。面试中哪些问题会被经常问到、自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li><li><strong>面试之前做好定向复习。</strong> 也就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</li><li><strong>准备好自己的项目介绍。</strong> 如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：①对项目整体设计的一个感受（面试官可能会让你画系统的架构图；②在这个项目中你负责了什么、做了什么、担任了什么角色；③ 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用；④项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li><li><strong>面试之后记得复盘。</strong> 面试遭遇失败是很正常的事情，所以善于总结自己的失败原因才是最重要的。如果失败，不要灰心；如果通过，切勿狂喜。</li></ol><p><strong>一些还算不错的 Java面试/学习相关的仓库，相信对大家准备面试一定有帮助：</strong><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484817&amp;idx=1&amp;sn=12f0c254a240c40c2ccab8314653216b&amp;chksm=fd9853f0caefdae6d191e6bf085d44ab9c73f165e3323aa0362d830e420ccbfad93aa5901021&amp;token=766994974&amp;lang=zh_CN#rd" target="_blank" rel="noopener">盘点一下Github上开源的Java面试/学习相关的仓库，看完弄懂薪资至少增加10k</a></p><h3 id="Question5-我该自学还是报培训班呢？"><a href="#Question5-我该自学还是报培训班呢？" class="headerlink" title="Question5: 我该自学还是报培训班呢？"></a>Question5: 我该自学还是报培训班呢？</h3><p>　　我本人更加赞同自学（你要知道去了公司可没人手把手教你了，而且几乎所有的公司都对培训班出生的有偏见。为什么有偏见，你学个东西还要去培训班，说明什么，同等水平下，你的自学能力以及自律能力一定是比不上自学的人的）。但是如果，你连每天在寝室坚持学上8个小时以上都坚持不了，或者总是容易半途而废的话，我还是推荐你去培训班。观望身边同学去培训班的，大多是非计算机专业或者是没有自律能力以及自学能力非常差的人。</p><p>　　另外，如果自律能力不行，你也可以通过结伴学习、参加老师的项目等方式来督促自己学习。</p><p>　　总结：去不去培训班主要还是看自己，如果自己能坚持自学就自学，坚持不下来就去培训班。</p><h3 id="Question6-没有项目经历-博客-Github开源项目怎么办？"><a href="#Question6-没有项目经历-博客-Github开源项目怎么办？" class="headerlink" title="Question6: 没有项目经历/博客/Github开源项目怎么办？"></a>Question6: 没有项目经历/博客/Github开源项目怎么办？</h3><p>　　从现在开始做！</p><p>　　网上有很多非常不错的项目视频，你就跟着一步一步做，不光要做，还要改进，改善。另外，如果你的老师有相关 Java 后台项目的话，你也可以主动申请参与进来。</p><p>　　如果有自己的博客，也算是简历上的一个亮点。建议可以在掘金、Segmentfault、CSDN等技术交流社区写博客，当然，你也可以自己搭建一个博客（采用 Hexo+Githu Pages 搭建非常简单）。写一些什么？学习笔记、实战内容、读书笔记等等都可以。</p><p>　　多用 Github，用好 Github，上传自己不错的项目，写好 readme 文档，在其他技术社区做好宣传。相信你也会收获一个不错的开源项目！</p><h3 id="Question7-大厂到底青睐什么样的应届生？"><a href="#Question7-大厂到底青睐什么样的应届生？" class="headerlink" title="Question7: 大厂到底青睐什么样的应届生？"></a>Question7: 大厂到底青睐什么样的应届生？</h3><p>　　从阿里、腾讯等大厂招聘官网对于Java后端方向/后端方向的应届实习生的要求，我们大概可以总结归纳出下面这 4 点能给简历增加很多分数：</p><ul><li>参加过竞赛（含金量超高的是ACM）；</li><li>对数据结构与算法非常熟练；</li><li>参与过实际项目（比如学校网站）；</li><li>参与过某个知名的开源项目或者自己的某个开源项目很不错；</li></ul><p>　　除了我上面说的这三点，在面试Java工程师的时候，下面几点也提升你的个人竞争力：</p><ul><li>熟悉Python、Shell、Perl等脚本语言；</li><li>熟悉 Java 优化，JVM调优；</li><li>熟悉 SOA 模式；</li><li>熟悉自己所用框架的底层知识比如Spring；</li><li>了解分布式一些常见的理论；</li><li>具备高并发开发经验；大数据开发经验等等。</li></ul><p><a href="&quot;https://github.com/Snailclimb/JavaGuide&quot;">原文出处</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　身边的朋友或者公众号的粉丝很多人都向我询问过:“我是双非/三本/专科学校的，我有机会进入大厂吗？”、“非计算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学那些东西？”、“我该如何准备Java面试？”……这些方面的问题。我会根据自己的一点经验对大部分人关心的这些问题进行答疑解惑。现在又刚好赶上考研结束，这篇文章也算是给考研结束准备往Java后端方向发展的朋友们指名一条学习之路。道理懂了如果没有实际行动，那这篇文章对你或许没有任何意义。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://xxyxt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="经验" scheme="https://xxyxt.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="转载" scheme="https://xxyxt.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>匿名内部类</title>
    <link href="https://xxyxt.github.io/2019/01/18/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://xxyxt.github.io/2019/01/18/匿名内部类/</id>
    <published>2019-01-18T06:09:06.859Z</published>
    <updated>2019-01-18T06:25:05.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h3><ul><li>在一个类的内部定义了另外一个类，利用内部类，可以实现私有属性的互相访问</li></ul><h3 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h3><ul><li>没有名字的内部类，必须在抽象类和接口的基础上才可以定义</li></ul><a id="more"></a><h3 id="解决的痛点："><a href="#解决的痛点：" class="headerlink" title="解决的痛点："></a>解决的痛点：</h3><ul><li>如果定义的一个内部类只使用一次便不再使用了，那么就没有必要将其定义为一个具体的类，所以这时便需要一个使用完便不存在的内部类结构，匿名内部类就很好的解决了这个问题</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Mesage</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDemo6</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">fun(<span class="keyword">new</span> Mesage() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span>(<span class="params">Mesage msg</span>)</span> &#123;</span><br><span class="line">msg.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用fun()函数时直接实例化借口对象，同时覆写抽象方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内部类：&quot;&gt;&lt;a href=&quot;#内部类：&quot; class=&quot;headerlink&quot; title=&quot;内部类：&quot;&gt;&lt;/a&gt;内部类：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在一个类的内部定义了另外一个类，利用内部类，可以实现私有属性的互相访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;匿名内部类：&quot;&gt;&lt;a href=&quot;#匿名内部类：&quot; class=&quot;headerlink&quot; title=&quot;匿名内部类：&quot;&gt;&lt;/a&gt;匿名内部类：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;没有名字的内部类，必须在抽象类和接口的基础上才可以定义&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://xxyxt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Object类</title>
    <link href="https://xxyxt.github.io/2019/01/17/Object/"/>
    <id>https://xxyxt.github.io/2019/01/17/Object/</id>
    <published>2019-01-17T07:23:02.089Z</published>
    <updated>2019-01-17T08:06:16.330Z</updated>
    
    <content type="html"><![CDATA[<p>Object类是所有类的父类，在定义类时，如果没有明确定义继承哪一种类，那就是继承Object类<br>Object类的三个覆写方法：</p><ul><li>public String toString()             取得对象信息</li><li>public boolean equals(Object obj)    对象比较</li><li>public int hashCode()                取得对象的哈希值</li></ul><a id="more"></a><h2 id="toString-取得对象信息"><a href="#toString-取得对象信息" class="headerlink" title="toString() 取得对象信息"></a>toString() 取得对象信息</h2><p><strong>默认情况下，直接输出一个对象，会输出对象的编码</strong> 但是String类型却不是如此，代码如下<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">testDemo4</span> </span>&#123;</span><br><span class="line">public static void main(<span class="type">String</span> args[]) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="type">A</span>=<span class="keyword">new</span> <span class="type">Book</span>();</span><br><span class="line"><span class="type">Object</span> <span class="type">B</span>=<span class="string">"xxyxt"</span>;</span><br><span class="line"><span class="type">System</span>.out.println(<span class="type">A</span>);</span><br><span class="line"><span class="type">System</span>.out.println(<span class="type">A</span>.toString());</span><br><span class="line"><span class="type">System</span>.out.println(<span class="type">B</span>);</span><br><span class="line"><span class="type">System</span>.out.println(<span class="type">B</span>.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="type">Book</span>@<span class="number">15</span>db9742</span><br><span class="line"><span class="type">Book</span>@<span class="number">15</span>db9742</span><br><span class="line">xxyxt</span><br><span class="line">xxyxt</span><br></pre></td></tr></table></figure></p><p><strong>可以看出：在输出一个对象时，不管调用和toString与否，都会直接输出对象的编码，但是在输出String类的时候，没有输出对象的编码，这是因为，String类中已经覆写了toString方法</strong></p><p>下面覆写一个toString()方法<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BB</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BB</span>(<span class="params">String name,<span class="keyword">double</span> price</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"书名:"</span> +<span class="keyword">this</span>.name + <span class="string">"价格："</span>+<span class="keyword">this</span>.price; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDemo5</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">BB b=<span class="keyword">new</span> BB(<span class="string">"Java从入门到放弃"</span>,<span class="number">48.9</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">书名:Java从入门到放弃  价格：<span class="number">48.9</span></span><br></pre></td></tr></table></figure></p><h2 id="equals-对象比较"><a href="#equals-对象比较" class="headerlink" title="equals() 对象比较"></a>equals() 对象比较</h2><p>默认的equals方法比较的是对象的内存地址数值，但是这并不符合真正的对象比较的需要，通过覆写，可以实现对象的比较的标准方法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name,<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>==obj)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(obj==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Book)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Book book=(Book) obj;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(book.name) &amp;&amp; <span class="keyword">this</span>.price==book.price)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"书名："</span>+ <span class="keyword">this</span>.name +<span class="string">"价格："</span>+<span class="keyword">this</span>.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo4</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Book b1=<span class="keyword">new</span> Book(<span class="string">"入坑"</span>,<span class="number">99.9</span>);</span><br><span class="line">Book b2=<span class="keyword">new</span> Book(<span class="string">"脱坑"</span>,<span class="number">0.01</span>);</span><br><span class="line">System.out.println(b1.equals(b2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Object类与引用数据类型"><a href="#Object类与引用数据类型" class="headerlink" title="Object类与引用数据类型"></a>Object类与引用数据类型</h2><p>Object是所有类的父类，可以接受所有类的对象，同时夜里可以接收所有引用数据类型，包括数组/接口/类<br>注意：接口不会继承任何类，相应的也不会继承Object类，可以使用Object接收是因为接口是引用数据类型</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object类是所有类的父类，在定义类时，如果没有明确定义继承哪一种类，那就是继承Object类&lt;br&gt;Object类的三个覆写方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public String toString()             取得对象信息&lt;/li&gt;
&lt;li&gt;public boolean equals(Object obj)    对象比较&lt;/li&gt;
&lt;li&gt;public int hashCode()                取得对象的哈希值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://xxyxt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="https://xxyxt.github.io/2019/01/17/%E6%8E%A5%E5%8F%A3/"/>
    <id>https://xxyxt.github.io/2019/01/17/接口/</id>
    <published>2019-01-17T03:35:31.250Z</published>
    <updated>2019-01-17T06:35:42.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h2><p><strong>有抽象方法和全局常量组成的类称之为接口</strong><br><a id="more"></a></p><h3 id="使用原则："><a href="#使用原则：" class="headerlink" title="使用原则："></a>使用原则：</h3><ul><li><p>接口必须有子类，子类可以使用inplements关键字实现多个接口，避免单继承的局限性</p></li><li><p>接口的子类必须覆写接口中全部的抽象方法</p></li><li><p>可以利用子类对象向上转型实现实例化</p></li><li><p>接口可以使用extends关键字同时继承多个父接口，但是不可以继承抽象类</p></li><li><p>一个子类如果既要继承抽象类也要实现接口，应该先继承，后实现接口</p></li></ul><h3 id="接口的限制"><a href="#接口的限制" class="headerlink" title="接口的限制"></a>接口的限制</h3><ul><li><p>接口的限制要比抽象类的限制要少</p></li><li><p>抽象类是单继承原则，但是接口可以多继承</p></li><li><p>从概念上讲，接口由抽象方法和全局常量组成，但是也可以在接口里面定义普通内部类，抽象内部类，内部接口</p></li><li><p>和抽象类类似，如果在接口的内部用static定义了一个内部接口，那么这个接口相当于一个外部接口</p></li></ul><h2 id="接口的实际应用——工厂设计模式-Factory"><a href="#接口的实际应用——工厂设计模式-Factory" class="headerlink" title="接口的实际应用——工厂设计模式(Factory)"></a>接口的实际应用——工厂设计模式(Factory)</h2><p><strong>忽略过程，直接得到结果，更少的修改客户端的代码</strong></p><ul><li><p>如果不采用工厂设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吃苹果"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Fruit f=<span class="keyword">new</span> Apple();</span><br><span class="line">f.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果客户端想要再增加一个吃橘子的类，那么就会修改客户端的代码，采用<strong>工厂设计模式就</strong>可以避免这种直接修改客户端的操作<br>代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Fruit</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span> <span class="title">implements</span> <span class="title">Fruit</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"eat apple"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Orange</span> <span class="title">implements</span> <span class="title">Fruit</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"eat orange"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Factory</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span>(<span class="params">String className</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"apple"</span>.<span class="keyword">equals</span>(className)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"orange"</span>.<span class="keyword">equals</span>(className))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Orange();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testDemo3</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">Fruit f=Factory.getInstance(<span class="string">"orange"</span>);</span><br><span class="line">f.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口的实际应用——代理设计模式-Proxy"><a href="#接口的实际应用——代理设计模式-Proxy" class="headerlink" title="接口的实际应用——代理设计模式(Proxy)"></a>接口的实际应用——代理设计模式(Proxy)</h2><h3 id="代理设计模式的实现——以代理上网为例"><a href="#代理设计模式的实现——以代理上网为例" class="headerlink" title="代理设计模式的实现——以代理上网为例"></a>代理设计模式的实现——以代理上网为例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Network</span></span>&#123;                   <span class="comment">//定义接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;            <span class="comment">//定义浏览抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Real</span> <span class="keyword">implements</span> <span class="title">Network</span></span>&#123;       <span class="comment">//真实上网操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;           <span class="comment">//覆写抽象方法</span></span><br><span class="line">System.out.println(<span class="string">"上网浏览"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Network</span></span>&#123;      <span class="comment">//代理上网</span></span><br><span class="line"><span class="keyword">private</span> Network network;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Network network)</span> </span>&#123;  <span class="comment">//代理的真实操作</span></span><br><span class="line"><span class="keyword">this</span>.network=network;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;             <span class="comment">//具体上网相关的操作</span></span><br><span class="line">System.out.println(<span class="string">"检查用户合法性"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.check();                  <span class="comment">//调用与上网相关的具体操作</span></span><br><span class="line"><span class="keyword">this</span>.network.browse();         <span class="comment">//调用真实上网操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tesnDemo2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">Network net=<span class="keyword">null</span>;                <span class="comment">//定义接口对象</span></span><br><span class="line">net=<span class="keyword">new</span> Proxy(<span class="keyword">new</span> Real());       <span class="comment">//实例化代理，同时传入代理的真实操作</span></span><br><span class="line">net.browse();                   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于接口&quot;&gt;&lt;a href=&quot;#关于接口&quot; class=&quot;headerlink&quot; title=&quot;关于接口&quot;&gt;&lt;/a&gt;关于接口&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;有抽象方法和全局常量组成的类称之为接口&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://xxyxt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>翻转连续最长子序列</title>
    <link href="https://xxyxt.github.io/2019/01/16/%E7%BF%BB%E8%BD%AC%E8%BF%9E%E7%BB%AD%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://xxyxt.github.io/2019/01/16/翻转连续最长子序列/</id>
    <published>2019-01-16T11:56:44.946Z</published>
    <updated>2019-01-16T12:11:50.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>有一个仅包含a和b两种字符的字符串s，长度为n，每次操作可以把一个字符做一次转换（把一个a设置为b，或者把一个b置成a)；但是操作的次数有上限m，问在有限的操作数范围内，能够得到最大连续的相同字符的子串的长度是多少。</li></ul><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><ul><li>第一行两个整数 n , m (1&lt;=m&lt;=n&lt;=50000)，第二行为长度为n且只包含a和b的字符串s。</li></ul><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><ul><li>输出在操作次数不超过 m 的情况下，能够得到的 最大连续 全a子串或全b子串的长度。<a id="more"></a></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">1</span></span><br><span class="line">aabaabaa</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="分析-以翻转a为例"><a href="#分析-以翻转a为例" class="headerlink" title="分析(以翻转a为例)"></a>分析(以翻转a为例)</h2><ul><li>翻转的操作次数为m，如果可以找出包含m个a的最长连续子串，然后将m个a翻转，即为本题的答案。</li><li>将a的下标组成新的数组array,则包含m个a连续序列的长度为 array[i+m]-array[i-1]-1;</li><li>如果这m个a中包含序列中的第一个或者最后一个a，那么，连续序列的长度为 array[i+m]-array[i-1];</li></ul><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50040</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longstr</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> k)</span>  <span class="comment">//输出最长连续序列函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=str.length();</span><br><span class="line">    <span class="keyword">int</span> arraya[maxn]=&#123;<span class="number">0</span>&#125;;      <span class="comment">//字符串中所有元素'a'的下标组成的数列 </span></span><br><span class="line">    <span class="keyword">int</span> arrayb[maxn]=&#123;<span class="number">0</span>&#125;;      <span class="comment">//字符串中所有元素'b'的下标组成的数列 </span></span><br><span class="line">    <span class="keyword">int</span> J=<span class="number">1</span>;                   <span class="comment">//计数符 </span></span><br><span class="line">    <span class="keyword">int</span> K=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxa=<span class="number">0</span>;                <span class="comment">//记录最大长度 </span></span><br><span class="line">    <span class="keyword">int</span> maxb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)     <span class="comment">//遍历字符串，生成目标数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'a'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arraya[J++]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'b'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             arrayb[K++]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">    arraya[J]=len;           <span class="comment">//添加首末元素 </span></span><br><span class="line">    arrayb[K]=len;</span><br><span class="line">    arraya[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    arrayb[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp1,temp2;         <span class="comment">//记录每一个遍历的连续字符串长度 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=J-k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span> || i==J-k)     <span class="comment">//如果要反转的字符在第一个或者最后一个 </span></span><br><span class="line">        &#123;</span><br><span class="line">            temp1=arraya[i+k]-arraya[i<span class="number">-1</span>];  <span class="comment">//不需要减去1 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp1=arraya[i+k]-arraya[i<span class="number">-1</span>]<span class="number">-1</span>;  <span class="comment">//否则需要减去1 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp1&gt;maxa)</span><br><span class="line">        &#123;</span><br><span class="line">            maxa=temp1;           <span class="comment">//将最大值保存 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K-k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span> || i==K-k)</span><br><span class="line">        &#123;</span><br><span class="line">             temp2=arrayb[i+k]-arrayb[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">             temp2=arrayb[i+k]-arrayb[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp2&gt;maxb)</span><br><span class="line">        &#123;</span><br><span class="line">            maxb=temp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a=(maxa&gt;maxb)?maxa:maxb;   <span class="comment">//找出翻转a和b中最长的序列 </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">        <span class="keyword">int</span> len=str.length();</span><br><span class="line">        longstr(str,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;有一个仅包含a和b两种字符的字符串s，长度为n，每次操作可以把一个字符做一次转换（把一个a设置为b，或者把一个b置成a)；但是操作的次数有上限m，问在有限的操作数范围内，能够得到最大连续的相同字符的子串的长度是多少。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;第一行两个整数 n , m (1&amp;lt;=m&amp;lt;=n&amp;lt;=50000)，第二行为长度为n且只包含a和b的字符串s。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;输出在操作次数不超过 m 的情况下，能够得到的 最大连续 全a子串或全b子串的长度。
    
    </summary>
    
      <category term="刷题笔记" scheme="https://xxyxt.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://xxyxt.github.io/tags/C-C/"/>
    
      <category term="2018笔试题" scheme="https://xxyxt.github.io/tags/2018%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>多态性</title>
    <link href="https://xxyxt.github.io/2019/01/15/%E5%A4%9A%E6%80%81%E6%80%A7/"/>
    <id>https://xxyxt.github.io/2019/01/15/多态性/</id>
    <published>2019-01-15T12:35:19.857Z</published>
    <updated>2019-01-16T03:09:19.014Z</updated>
    
    <content type="html"><![CDATA[<p>多态性主要在两个方面：</p><ol><li><p>方法多态</p><ul><li>覆写</li><li>重载</li></ul></li><li><p>对象多态</p><ul><li>对象的多态性为父子类对象的转换</li><li>向上转型：父类 父类对象 = 子类实例</li><li>向下转型：子类 子类对象 = (子类) 父类实例</li><li>必须发生向上转型之后才可以发生向下转型</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多态性主要在两个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;方法多态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;覆写&lt;/li&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象多态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象的多态性为父子类对象的转换&lt;/li&gt;
&lt;li&gt;向上转型：父类 父
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>子类的覆写</title>
    <link href="https://xxyxt.github.io/2019/01/15/%E8%A6%86%E5%86%99/"/>
    <id>https://xxyxt.github.io/2019/01/15/覆写/</id>
    <published>2019-01-15T11:46:27.553Z</published>
    <updated>2019-01-15T12:21:20.917Z</updated>
    
    <content type="html"><![CDATA[<p>子类可以继承父类的属性和方法，也可以在父类的基础上进行拓展，也可以根据父类已有的方法名进行再次定义，我们可以称之为覆写</p><h2 id="方法的覆写"><a href="#方法的覆写" class="headerlink" title="方法的覆写"></a>方法的覆写</h2><a id="more"></a><ul><li><p>子类定义的方法名称、返回值类型、参数类型及个数与父类完全相同，称之为方法的覆写</p></li><li><p>被子类覆写的方法，不能拥有比父类更严格的访问权限</p></li><li><p>访问权限从宽到严的顺序为：public &gt; default &gt; private</p></li><li><p>父类方法的访问权限如果是private，则不能够被覆写，可以通过super.fangfa()来进行调用</p></li></ul><p><strong>方法重载(overloading)和覆写(overrid)的区别：</strong></p><ul><li><p>发生范围：重载发生在一个类里面，覆写发生在继承里面</p></li><li><p>权限：重载没有权限限制，继承的子类的覆写不能拥有比弗雷更加严格的访问限制</p></li><li><p>定义：重载参数类型及个数不同，覆写则都相同</p></li></ul><h2 id="属性的覆写"><a href="#属性的覆写" class="headerlink" title="属性的覆写"></a>属性的覆写</h2><ul><li><p>属性的覆写就是属性的覆写</p></li><li><p>实际开发中类的属性是被封装的，所以属性的覆写意义不大</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;子类可以继承父类的属性和方法，也可以在父类的基础上进行拓展，也可以根据父类已有的方法名进行再次定义，我们可以称之为覆写&lt;/p&gt;
&lt;h2 id=&quot;方法的覆写&quot;&gt;&lt;a href=&quot;#方法的覆写&quot; class=&quot;headerlink&quot; title=&quot;方法的覆写&quot;&gt;&lt;/a&gt;方法的覆写&lt;/h2&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java关键字</title>
    <link href="https://xxyxt.github.io/2019/01/15/this-static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://xxyxt.github.io/2019/01/15/this-static关键字/</id>
    <published>2019-01-15T02:24:03.984Z</published>
    <updated>2019-01-16T01:54:47.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this-关键字的用法"><a href="#this-关键字的用法" class="headerlink" title="this 关键字的用法"></a>this 关键字的用法</h2><p>Java开发离不开关键字this,this有三类用法：</p><h3 id="调用本类属性"><a href="#调用本类属性" class="headerlink" title="调用本类属性"></a>调用本类属性</h3><p>为了避免类的<strong>属性名称</strong>和<strong>方法参数名称</strong>的重复，需要用<strong>this.</strong>属性的形式，来明确指明调用的是属性而不是参数<br>注：为了避免不必要的麻烦，在访问类的属性时，不管名称重复与否，都加上this关键字</p><a id="more"></a><h3 id="调用本类方法"><a href="#调用本类方法" class="headerlink" title="调用本类方法"></a>调用本类方法</h3><p>类中的方法主要有两种：普通和构造方法。所以调用本类方法也有两种形式：</p><ul><li><p>普通方法：this.方法()</p></li><li><p>构造方法：this()</p><p>注：用this(),可以很好解决构造方法中的代码重复问题</p></li></ul><h3 id="表示当前对象"><a href="#表示当前对象" class="headerlink" title="表示当前对象"></a>表示当前对象</h3><ul><li>表示当前调用类中方法的实例化对象</li></ul><h2 id="static-关键字的用法"><a href="#static-关键字的用法" class="headerlink" title="static 关键字的用法"></a>static 关键字的用法</h2><h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><ul><li>在声明属性前加上static关键字，表示公共属性</li><li><p>公共属性，任何一个对象修改了此属性的内容都会影响其他的对象。好比一个人有多个名字，小张、狗蛋、二狗子，如果小张的腿摔断了，那么狗蛋和二狗子的腿也会摔断，因为他们是同一个人</p></li><li><p>static定义的属性保存在<strong>全局数据区</strong></p></li><li><p>static定义的属性可以由类直接调用，而非static属性必须在实例化对象之后，由对象调用</p></li><li><p>定义共享属性的时候才会使用static，一般情况都是使用非属性</p></li></ul><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>和定义属性一样，使用static定义普通方法时，没有经过实例化产生对象可以直接由类名直接调用</p><p>注意：</p><ul><li>static方法不能直接访问非static方法或属性</li><li>非static方法可以直接调用或访问static方法</li></ul><p>原因：</p><ul><li>非static结构在实例化对象之后才会分配堆空间，才可以使用</li><li>static不受实例化对象的控制</li></ul><h2 id="public-static-void-main-String-args"><a href="#public-static-void-main-String-args" class="headerlink" title="public static void main(String args[])"></a>public static void main(String args[])</h2><p>刚刚开始接触java时，感觉这个一大串好长，每个部分究竟各自代表什么意义，不写其中的任何一项可不可以</p><ul><li>public：表示此方法对任何操作都是可见的</li><li>static：此类方法由类名直接调用</li><li>void: 表示返回值为空</li><li>main: 规定的名称</li><li>String args[]: 程序运行时传递的参数，java类名 参数 参数 参数</li></ul><h2 id="final关键字的用法"><a href="#final关键字的用法" class="headerlink" title="final关键字的用法"></a>final关键字的用法</h2><ul><li><p>使用final定义的类不能再有子类，String类就是final定义的类</p></li><li><p>final定义的方法不能够被覆写 <figure class="highlight plain"><figcaption><span>final void fun()```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- final定义的变量变为常量 类似于C++里面的 const</span><br><span class="line"></span><br><span class="line">- 全局常量：即用public static final 3个关键字定义的常量 ``` public static final String xxy=&quot;LOVE&quot;</span><br></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this-关键字的用法&quot;&gt;&lt;a href=&quot;#this-关键字的用法&quot; class=&quot;headerlink&quot; title=&quot;this 关键字的用法&quot;&gt;&lt;/a&gt;this 关键字的用法&lt;/h2&gt;&lt;p&gt;Java开发离不开关键字this,this有三类用法：&lt;/p&gt;
&lt;h3 id=&quot;调用本类属性&quot;&gt;&lt;a href=&quot;#调用本类属性&quot; class=&quot;headerlink&quot; title=&quot;调用本类属性&quot;&gt;&lt;/a&gt;调用本类属性&lt;/h3&gt;&lt;p&gt;为了避免类的&lt;strong&gt;属性名称&lt;/strong&gt;和&lt;strong&gt;方法参数名称&lt;/strong&gt;的重复，需要用&lt;strong&gt;this.&lt;/strong&gt;属性的形式，来明确指明调用的是属性而不是参数&lt;br&gt;注：为了避免不必要的麻烦，在访问类的属性时，不管名称重复与否，都加上this关键字&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类的继承性</title>
    <link href="https://xxyxt.github.io/2019/01/15/Java%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7/"/>
    <id>https://xxyxt.github.io/2019/01/15/Java类的继承性/</id>
    <published>2019-01-15T01:56:27.641Z</published>
    <updated>2019-01-15T06:58:48.657Z</updated>
    
    <content type="html"><![CDATA[<p>继承性是面向对象的一个主要特征，主要解决了代码的重复利用的问题，利用继承性可以从已有的类中派生新的子类，也可以利用子类扩展出更多的操作<br><a id="more"></a><br>语法实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">子类</span> <span class="keyword">extends</span> <span class="title">父类</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>继承性的限制：<br>限制一：不可以多重继承，可以多层继承</p><ul><li>class A extends C,D    错误</li><li>class A{}    class B extends A{}    class C extends B{}</li><li>继承的层次不要过多<br>限制二：子类继承父类，会继承父类的全部操作，但是对于对于私有操作属于隐式继承，非私有操作属于显示继承<br>限制三：子类对象构造前，一定会默认调用<strong>父类的构造</strong>，父类对象先实例化，子类对象后实例化，所以子类对象相当于隐含了super()的 语句调用</li><li>注：父类中提供无参构造时，是否编写super()没有区别，如果没有无参构造，则必须明确使用super()调用父类指定的构造方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承性是面向对象的一个主要特征，主要解决了代码的重复利用的问题，利用继承性可以从已有的类中派生新的子类，也可以利用子类扩展出更多的操作&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="https://xxyxt.github.io/2019/01/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <id>https://xxyxt.github.io/2019/01/14/二叉树的几种遍历方法/</id>
    <published>2019-01-14T12:02:20.000Z</published>
    <updated>2019-01-14T12:13:12.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong>二叉树的遍历指按照一定的顺序访问二叉树的所有节点</strong></p><p>访问方法一共四种：先序遍历，中序遍历，后续遍历，层序遍历<br>前三种遍历一般用DFS方法，层序遍历需要BFS方法<br>先、中、后序遍历，都是指的根节点的访问顺序<br>先序代码：<br><a id="more"></a><br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void preorder(node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(root==NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="title">cout</span>&lt;&lt;root-&gt;</span><span class="keyword">data</span>;</span><br><span class="line"><span class="function"><span class="title">preorder</span>(root-&gt;</span>left);</span><br><span class="line"><span class="function"><span class="title">preorder</span>(root-&gt;</span>right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>中序代码：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void inorder(node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(root==NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">inorder</span>(root-&gt;</span>left);</span><br><span class="line"><span class="function"><span class="title">cout</span>&lt;&lt;root-&gt;</span><span class="keyword">data</span>;</span><br><span class="line"><span class="function"><span class="title">inorder</span>(root-&gt;</span>right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后续代码：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void postorder(node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(root==NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">postorder</span>(root-&gt;</span>left);</span><br><span class="line"><span class="function"><span class="title">postorder</span>(root-&gt;</span>right);</span><br><span class="line"><span class="function"><span class="title">cout</span>&lt;&lt;root-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>层序遍历，是按照层次的顺序，访问节点，采用广度优先的访问方法结合队列实现操作，代码如下：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void layerorder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="literal">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">node* <span class="built_in">now</span>=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">cout&lt;&lt;<span class="built_in">now</span>-&gt;data;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">now</span>-&gt;<span class="built_in">left</span>!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(<span class="built_in">now</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">now</span>-&gt;<span class="built_in">right</span>!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(<span class="built_in">now</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;二叉树的遍历指按照一定的顺序访问二叉树的所有节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问方法一共四种：先序遍历，中序遍历，后续遍历，层序遍历&lt;br&gt;前三种遍历一般用DFS方法，层序遍历需要BFS方法&lt;br&gt;先、中、后序遍历，都是指的根节点的访问顺序&lt;br&gt;先序代码：&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://xxyxt.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://xxyxt.github.io/2019/01/12/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://xxyxt.github.io/2019/01/12/最长回文子串/</id>
    <published>2019-01-12T06:57:24.000Z</published>
    <updated>2019-01-12T07:01:14.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>给出一个字符串S，求S的最长回文子串的长度。</p><p>例：字符串“ASDFGHGFDSB”的最长回文子串为“SDFGHGFDS”，长度为9。</p><p>显然暴力解法的不仅复杂度较大，而且超级繁琐，采用动态规划可以更好的解决这类问题<br><a id="more"></a></p><p>令dp[i][j]表示S[i]至S[j]所表示的子串是否回文，是则为1，不是则为0.这样可以根据S[i]和S[j]是否相等分为两种情况：</p><ol><li>如果S[i]==S[j]，那么只要S[i+1]至S[j-1]是回文子串，那么S[i]至S[j]也是回文子串；如果S[i+1]至S[j-1]不是回文子串，那么S[i]至S[j]也不是回文子串；</li><li>如果S[i]!=S[j]，那么S[i]至S[j]一定不是回文子串<br>边界：dp[i][i]=1, dp[i][i+1]=(S[i]==S[i+1])?1:0</li></ol><p><strong>注意：如果按照i和j从小到大的顺序来枚举子串的端点，然后更新dp[i][j]，这样会无法保证dp[i+1][j-1]已经得到计算，从而无法进行状态转移</strong>。</p><p>因为边界的子串长度为1和2，所以可以考虑按照子串的长度和初始位置进行枚举，即第一遍将子串长度为3的dp值全部求出来，第二遍计算长度为4的子串可以通过计算出的长度为3的子串的dp值进行计算。这样问题就可以得到解决</p><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">gets(S);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(S);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>; <span class="comment">//初始化最长回文子串长度为1 </span></span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt; len - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == S[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">ans = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">3</span>; L &lt;= len; L++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + L - <span class="number">1</span> &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (S[i] == S[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">ans = L;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><p><a href="https://www.nowcoder.com/practice/12e081cd10ee4794a2bd70c7d68f5507?tpId=37&amp;tqId=21308&amp;tPage=5&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/12e081cd10ee4794a2bd70c7d68f5507?tpId=37&amp;tqId=21308&amp;tPage=5&amp;rp=&amp;ru=%2Fta%2Fhuawei&amp;qru=%2Fta%2Fhuawei%2Fquestion-ranking</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;给出一个字符串S，求S的最长回文子串的长度。&lt;/p&gt;
&lt;p&gt;例：字符串“ASDFGHGFDSB”的最长回文子串为“SDFGHGFDS”，长度为9。&lt;/p&gt;
&lt;p&gt;显然暴力解法的不仅复杂度较大，而且超级繁琐，采用动态规划可以更好的解决这类问题&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="https://xxyxt.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="动态规划" scheme="https://xxyxt.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>01背包问题</title>
    <link href="https://xxyxt.github.io/2019/01/11/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://xxyxt.github.io/2019/01/11/01背包问题/</id>
    <published>2019-01-11T05:34:52.000Z</published>
    <updated>2019-01-11T12:26:57.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>问题：有n件物品，每件物品重量为w[ i ]，价值为c[ i ]。现有一个容量为V的背包，问如何选取物品放入背包，使背包总价值最大，其中每个物品只有一件。<br><a id="more"></a><br>样例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">5</span> V=<span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="comment">// w[ i ]</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> / / c[ i ]</span><br></pre></td></tr></table></figure></p><p>显然，对于每件物品有两种选择，暴力解法复杂度为O($2^n$)<br>用dp[i][v]表示第i件物品放入容量为v的背包，则dp[i][v]的值求解有两种选择：</p><ol><li>不放入第i件物品，那么问题转化为前i-1件物品放入容量为v的背包获得的最大价值，dp[ i-1 ][ v ]</li><li>放入第i件物品，那么问题转化为前i-1件物品放入容量为v-w[i]的背包获得的最大价值<br>dp[ i-1][ v-w[ i ] ]+c[ i ]</li></ol><p><strong>公式为</strong>：dp[ i ][ v ] = max{ dp[ i-1 ][ v ], dp[ i-1 ][ v - w[ i ] ] + c[ i ] }<br>第i件物品的状态，只与第i-1件物品的状态有关，所以可以通过边界dp[0][v]=0(0&lt;=v&lt;=V)，递推得到整个数组</p><h4 id="二维数组实现代码："><a href="#二维数组实现代码：" class="headerlink" title="二维数组实现代码："></a>二维数组实现代码：</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=n;<span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int v=w[<span class="built_in">i</span>];w[<span class="built_in">i</span>]&lt;V;v++)</span><br><span class="line">&#123;</span><br><span class="line">dp[<span class="built_in">i</span>][v]=<span class="built_in">max</span>(dp[<span class="built_in">i</span><span class="number">-1</span>][v],dp[<span class="built_in">i</span><span class="number">-1</span>][v-w[<span class="built_in">i</span>]]+c[<span class="built_in">i</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样计算得出的dp[ n ][ V ]的值即为最大值</strong><br>其实上面的代码还可以在空间复杂度上进行优化，可以看出，在计算dp[i+1][v]的值时，dp[i-1][v]的值没有用到，因此不妨直接用一维数组来代替二维数组，枚举方向从1到n,v从V到0，状态转移方程变为：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp<span class="comment">[ v ]</span> = max(dp<span class="comment">[ v ]</span>,dp<span class="comment">[ v-w<span class="comment">[ i ]</span>]</span>+c<span class="comment">[ i ]</span>)</span><br></pre></td></tr></table></figure></p><h4 id="一维数组实现代码："><a href="#一维数组实现代码：" class="headerlink" title="一维数组实现代码："></a>一维数组实现代码：</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">1</span>;<span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int v = V; v&gt;=w [ <span class="built_in">i</span> ]; v--)</span><br><span class="line">&#123;</span><br><span class="line">dp[ v ] = <span class="built_in">max</span>(dp[ v ], dp[ v - w[ <span class="built_in">i</span> ]] + c[ <span class="built_in">i</span> ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样得到的最大值，需要在数组dp里面找出最大值，不是dp[ V ]</strong></p><h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><p><a href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&amp;tqId=21239&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&amp;tqId=21239&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;01背包问题&quot;&gt;&lt;a href=&quot;#01背包问题&quot; class=&quot;headerlink&quot; title=&quot;01背包问题&quot;&gt;&lt;/a&gt;01背包问题&lt;/h2&gt;&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;问题：有n件物品，每件物品重量为w[ i ]，价值为c[ i ]。现有一个容量为V的背包，问如何选取物品放入背包，使背包总价值最大，其中每个物品只有一件。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="动态规划" scheme="https://xxyxt.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>安装pyinstaller报错</title>
    <link href="https://xxyxt.github.io/2019/01/11/%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/"/>
    <id>https://xxyxt.github.io/2019/01/11/安装报错/</id>
    <published>2019-01-11T02:28:47.000Z</published>
    <updated>2019-01-11T02:35:45.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装pyinstaller报错：Python-library-not-in-binary-dependencies"><a href="#安装pyinstaller报错：Python-library-not-in-binary-dependencies" class="headerlink" title="安装pyinstaller报错：Python library not in binary dependencies"></a>安装pyinstaller报错：Python library not in binary dependencies</h2><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>Centos7.0<br>Python3.6<br><a id="more"></a></p><h2 id="pyinstaller安装"><a href="#pyinstaller安装" class="headerlink" title="pyinstaller安装"></a>pyinstaller安装</h2><p>照着网上的一些教程安装了pyinstaller</p><pre><code>pip3 installer pyinstaller</code></pre><p>   将pyinstaller的路径添加到环境变量</p><pre><code>export PATH=$PATH:/usr/local/python3/lib/python3.6/site-packages</code></pre><p>修改配置文件，将上一条命令写入  /etc/profile 文件</p><pre><code>vi /etc/profile</code></pre><p>然后装完之后开始使用，试着打包自己刚刚写的一个py文件</p><pre><code>pyinstaller ex14.py</code></pre><p>然后就开始报错</p><pre><code>[root@VM_0_13_centos python_ex]# pyinstaller -F ex41.pyOSError: Python library not found: libpython3.6mu.so.1.0, libpython3.6.so.1.0, libpython3.6m.so.1.0This would mean your Python installation doesn&apos;t come with proper library files.This usually happens by missing development package, or unsuitable build parameters of Python installation.On Debian/Ubuntu, you would need to install Python development packages  * apt-get install python3-dev  * apt-get install python-dev  *  If you&apos;re building Python by yourself, please rebuild your Python with `--enable-shared` (or, `--enable-framework` on Darwin)</code></pre><p>解决办法<br>1打开  /etc/ld.so.conf 写入<br>/usr/local/lib64<br>/usr/local/lib</p><pre><code>vi /etc/ld.so.conf</code></pre><p>2</p><pre><code>ldconfig</code></pre><p>3</p><pre><code>pyinstaller ex14.py</code></pre><p>这样就解决问题了<br><img src="https://img-blog.csdn.net/20180927004219612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyMzkwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装pyinstaller报错：Python-library-not-in-binary-dependencies&quot;&gt;&lt;a href=&quot;#安装pyinstaller报错：Python-library-not-in-binary-dependencies&quot; class=&quot;headerlink&quot; title=&quot;安装pyinstaller报错：Python library not in binary dependencies&quot;&gt;&lt;/a&gt;安装pyinstaller报错：Python library not in binary dependencies&lt;/h2&gt;&lt;h2 id=&quot;运行环境&quot;&gt;&lt;a href=&quot;#运行环境&quot; class=&quot;headerlink&quot; title=&quot;运行环境&quot;&gt;&lt;/a&gt;运行环境&lt;/h2&gt;&lt;p&gt;Centos7.0&lt;br&gt;Python3.6&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://xxyxt.github.io/categories/python/"/>
    
    
      <category term="经验" scheme="https://xxyxt.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>使用Github+Hexo搭建自己的博客</title>
    <link href="https://xxyxt.github.io/2019/01/08/%E4%BD%BF%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://xxyxt.github.io/2019/01/08/使用Github-Hexo搭建自己的博客/</id>
    <published>2019-01-08T12:09:04.420Z</published>
    <updated>2019-01-12T07:00:52.542Z</updated>
    
    <content type="html"><![CDATA[<p>我的电脑是win10    64位的</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a><strong>前期准备</strong></h2><ul><li>去官网下载Node.js文件，下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>安装完成后，windows运行窗口输入：<code>node -v</code> 会出现版本信息，则安装成功</li></ul><a id="more"></a><ul><li>去官网下载Git安装包，下载地址：<a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">https://www.git-scm.com/download/win</a><br>按照默认的安装方式，一直点next即可安装成功，默认是安装在C盘，记得修改安装盘符<br>安装完成后，windows运行窗口输入：<code>git --version</code> 会出现版本信息，则安装成功</li></ul><p><strong>注意：安装成功之后，如果输入上述命令，没有出现对应的信息，则将安装路径添加到用户环境变量（我的是F:\Git\cmd)，再次打开运行窗口输入命令即可。</strong></p><h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><p>Github Pages 其实本身就是 Github 提供的博客服务。 我们在 Github 中创建一个特定格式的 Repository，Github Pages 就会将里面的信息生成一个网页，展示出来。</p><p><strong>操作如下：</strong></p><ol><li><p>注册 Github 账号，然后在 Github 中创建一个以 .github.io 结尾的 Repository。</p><ul><li style="list-style: none"><input type="checkbox"> Repository name: xxyxt.github.io</li><li style="list-style: none"><input type="checkbox"> 勾选 Initialize this repository with a README</li><li style="list-style: none"><input type="checkbox"> Create repository</li></ul></li><li>简单地编辑一下 README.md 这个文档。 比如添加：this is a test blog. 保存(Commit changes)。</li><li>打开网页：xxyxt.github.io 这里就可以看到 README.md 里的内容了。</li></ol><p>这个生成好的 Repository 就是用来存放博客内容的地方，也只有这个仓库里的内容，才会被 xxyxt.github.io 这个网页显示出来。</p><h2 id="hexo-博客框架"><a href="#hexo-博客框架" class="headerlink" title="hexo 博客框架"></a>hexo 博客框架</h2><ul><li><strong>安装hexo</strong></li></ul><p>在准备工作中，我们已经安装了<strong>Node.js</strong>和<strong>Git</strong>，接下来直接安装 hexo 即可</p><ul><li style="list-style: none"><input type="checkbox"> 在windows运行命令窗口中输入 <code>nmp install -g hexo-cli</code></li></ul><ul><li style="list-style: none"><input type="checkbox"> 安装完成后，输入 <code>hexo -v</code></li></ul><p>得到版本信息，即安装成功</p><ul><li><p><strong>设置全局配置 user.name 和 user.email</strong><br>鼠标右击，单击Git bash here，打开命令窗口，输入</p><p>  <code>git config –-global user.name “张三”</code>  //(“”的账号是刚才Github里面自己注册的账号)<br>  <code>git config –-global user.email “1234567@qq.com”</code> //(“”的邮箱是你自己注册的邮箱)</p></li><li><p><strong>生成SSH密钥设置到Github</strong><br><code>cd ~/.ssh</code><br><code>ssh-keygen -t rsa -C “username”</code>  //这里的username为计算机名<br>如果  <code>cd ~/.ssh</code> 显示No such file，可以输入命令 <code>mkdir ~/.ssh</code> 创建一个文件夹，然后执行相应的操作即可，出现下图，则设置成功<img src="https://img-blog.csdnimg.cn/20190108185113300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyMzkwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>设置ssh key到GitHub 默认生成ssh key在C:\Users\username.ssh文件夹中，用记事本打开 id_rsa.pub文件，复制 i文件内容到 github-&gt;settings-&gt;SSH and GPG key-&gt;new ssh-&gt;key </p></li><li><p><strong>ssh设置是否成功测试</strong></p><p>  输入命令 <code>ssh -T git@github.com</code> </p></li><li><p><strong>创建本地博客</strong></p></li></ul><ul><li style="list-style: none"><input type="checkbox"> 在D盘下创建文件夹 test</li></ul><ul><li style="list-style: none"><input type="checkbox"> 鼠标右键 test，选择 Git Bash Here</li></ul><ul><li style="list-style: none"><input type="checkbox"> Git Bash 打开之后，所在的位置就是 test 这个文件夹的位置。（/F/test）</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo init</code> 将 test文件夹初始化成一个博客文件夹。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>npm install</code> 安装依赖包。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo g</code> 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo s</code> 将生成的网页放在了本地服务器（server）。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 浏览器里输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 。 就可以看到刚才的成果了。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 回到 Git Bash，按 Ctrl+C 结束。<br>此时再看 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就是无法访问了。</li></ul><p>问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号</p><ul><li><strong>发布一篇博客</strong></li></ul><p>如果你按照前面的教程走下来，没有退出刚刚的Git Bash界面，当前路径是刚刚初始化的test路径，输入 <code>hexo new &quot;My First Post&quot;</code></p><ul><li style="list-style: none"><input type="checkbox"> 在<code>F:\test\source_posts</code>路径下，会有一个 My-First-Post.md 的文件。 编辑这个文件，然后保存。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 回到 Git Bash，输入 <code>hexo g</code> 生成博客</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo s</code> 开启服务</li></ul><ul><li style="list-style: none"><input type="checkbox"> 前往 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看成果。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 回到 Git Bash，按 Ctrl+C 结束。如果不结束的话，接口会一直被占用。</li></ul><ul><li><strong>将本地Hexo博客部署在Github上</strong></li></ul><p>前面两个部分，我们已经有了本地博客，和一个能托管这些资料的线上仓库。只要把本地博客部署（deploy）在我们的 Github 对应的 Repository 就可以了。</p><h6 id="操作如下："><a href="#操作如下：" class="headerlink" title="操作如下："></a>操作如下：</h6><ol><li><p>获取 Github 对应的 Repository 的链接。</p><ul><li style="list-style: none"><input type="checkbox"> 登陆 Github，进入到 xxyxt.github.io    </li><li style="list-style: none"><input type="checkbox"> 点击 Clone or download    </li><li style="list-style: none"><input type="checkbox"> 复制 URL 待用，我的是 <a href="https://github.com/xxyxt/xxyxt.github.io.git" target="_blank" rel="noopener">https://github.com/xxyxt/xxyxt.github.io.git</a></li></ul></li></ol><ol start="2"><li><p>修改博客的配置文件</p><ul><li style="list-style: none"><input type="checkbox"> 打开配置文件 /F/test/_config.yml （使用 bash 里的 vi 或者 notepad）</li><li style="list-style: none"><input type="checkbox"> 找到 #Deployment，填入以下内容：<br>deploy:<br>type: git<br>repository: <a href="https://github.com/xxyxt/xxyxt.github.io.git" target="_blank" rel="noopener">https://github.com/xxyxt/xxyxt.github.io.git</a><br>branch: master</li></ul></li></ol><ol start="3"><li>部署</li></ol><ul><li style="list-style: none"><input type="checkbox"> 回到 Git Bash 输入 <code>npm install hexo-deployer-git --save</code> 安装 hexo-deployer-git 此步骤只需要做一次。</li><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo d</code></li><li style="list-style: none"><input type="checkbox"> 得到 INF Deploy done: git 即为部署成功</li></ul><p>之前我们创建的 ReadMe.md 会被自动覆盖掉。</p><ol start="4"><li>查看成果</li></ol><p>前往 xxyxt.github.io 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的电脑是win10    64位的&lt;/p&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;&lt;strong&gt;前期准备&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;去官网下载Node.js文件，下载地址：&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;br&gt;安装完成后，windows运行窗口输入：&lt;code&gt;node -v&lt;/code&gt; 会出现版本信息，则安装成功&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="博客" scheme="https://xxyxt.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
