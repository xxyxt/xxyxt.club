<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>下雪不下雨的个人博客</title>
  
  <subtitle>to be a learner</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xxyxt.github.io/"/>
  <updated>2019-01-20T03:59:10.000Z</updated>
  <id>https://xxyxt.github.io/</id>
  
  <author>
    <name>xxyxt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://xxyxt.github.io/2019/01/20/java-programmer-need-know/"/>
    <id>https://xxyxt.github.io/2019/01/20/java-programmer-need-know/</id>
    <published>2019-01-20T07:48:40.000Z</published>
    <updated>2019-01-20T03:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　身边的朋友或者公众号的粉丝很多人都向我询问过:“我是双非/三本/专科学校的，我有机会进入大厂吗？”、“非计算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学那些东西？”、“我该如何准备Java面试？”……这些方面的问题。我会根据自己的一点经验对大部分人关心的这些问题进行答疑解惑。现在又刚好赶上考研结束，这篇文章也算是给考研结束准备往Java后端方向发展的朋友们指名一条学习之路。道理懂了如果没有实际行动，那这篇文章对你或许没有任何意义。</p><h3 id="Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？"><a href="#Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？" class="headerlink" title="Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？"></a>Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？</h3><p>　　我自己也是非985非211学校的，结合自己的经历以及一些朋友的经历，我觉得让我回答这个问题再好不过。</p><p>　　首先，我觉得学校歧视很正常，真的太正常了，如果要抱怨的话，你只能抱怨自己没有进入名校。但是，千万不要动不动说自己学校差，动不动拿自己学校当做自己进不了大厂的借口，学历只是筛选简历的很多标准中的一个而已，如果你够优秀，简历够丰富，你也一样可以和名校同学一起同台竞争。</p><p>　　企业HR肯定是更喜欢高学历的人，毕竟985，211优秀人才比例肯定比普通学校高很多，HR团队肯定会优先在这些学校里选。这就好比相亲，你是愿意在很多优秀的人中选一个优秀的，还是愿意在很多普通的人中选一个优秀的呢？<br>　　<br>　　双非本科甚至是二本、三本甚至是专科的同学也有很多进入大厂的，不过比率相比于名校的低很多而已。从大厂招聘的结果上看，高学历人才的数量占据大头，那些成功进入BAT、美团，京东，网易等大厂的双非本科甚至是二本、三本甚至是专科的同学往往是因为具备丰富的项目经历或者在某个含金量比较高的竞赛比如ACM中取得了不错的成绩。<strong>一部分学历不突出但能力出众的面试者能够进入大厂并不是说明学历不重要，而是学历的软肋能够通过其他的优势来弥补。</strong> 所以，如果你的学校不够好而你自己又想去大厂的话，建议你可以从这几点来做：<strong>①尽量在面试前最好有一个可以拿的出手的项目；②有实习条件的话，尽早出去实习，实习经历也会是你的简历的一个亮点（有能力在大厂实习最佳！）；③参加一些含金量比较高的比赛，拿不拿得到名次没关系，重在锻炼。</strong></p><h3 id="Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？"><a href="#Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？" class="headerlink" title="Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？"></a>Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？</h3><p>　　当然可以！现在非科班的程序员很多，很大一部分原因是互联网行业的工资比较高。我们学校外面的培训班里面90%都是非科班，我觉得他们很多人学的都还不错。另外，我的一个朋友本科是机械专业，大一开始自学安卓，技术贼溜，在我看来他比大部分本科是计算机的同学学的还要好。参考Question1的回答，即使你是非科班程序员，如果你想进入大厂的话，你也可以通过自己的其他优势来弥补。</p><p>　　我觉得我们不应该因为自己的专业给自己划界限或者贴标签，说实话，很多科班的同学可能并不如你，你以为科班的同学就会认真听讲吗？还不是几乎全靠自己课下自学！不过如果你是非科班的话，你想要学好，那么注定就要舍弃自己本专业的一些学习时间，这是无可厚非的。</p><p>　　建议非科班的同学，首先要打好计算机基础知识基础：①计算机网络、②操作系统、③数据机构与算法，我个人觉得这3个对你最重要。这些东西就像是内功，对你以后的长远发展非常有用。当然，如果你想要进大厂的话，这些知识也是一定会被问到的。另外，“一定学好数据机构与算法！一定学好数据机构与算法！一定学好数据机构与算法！”，重要的东西说3遍。</p><h3 id="Question3-我没有实习经历的话找工作是不是特别艰难？"><a href="#Question3-我没有实习经历的话找工作是不是特别艰难？" class="headerlink" title="Question3: 我没有实习经历的话找工作是不是特别艰难？"></a>Question3: 我没有实习经历的话找工作是不是特别艰难？</h3><p>　　没有实习经历没关系，只要你有拿得出手的项目或者大赛经历的话，你依然有可能拿到大厂的 offer 。笔主当时找工作的时候就没有实习经历以及大赛获奖经历，单纯就是凭借自己的项目经验撑起了整个面试。</p><p>　　如果你既没有实习经历，又没有拿得出手的项目或者大赛经历的话，我觉得在简历关，除非你有其他特别的亮点，不然，你应该就会被刷。</p><h3 id="Question4-我该如何准备面试呢？面试的注意事项有哪些呢？"><a href="#Question4-我该如何准备面试呢？面试的注意事项有哪些呢？" class="headerlink" title="Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？"></a>Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？</h3><p>下面是我总结的一些准备面试的Tips以及面试必备的注意事项：</p><ol><li><strong>准备一份自己的自我介绍，面试的时候根据面试对象适当进行修改</strong>（突出重点，突出自己的优势在哪里，切忌流水账）；</li><li><strong>注意随身带上自己的成绩单和简历复印件；</strong> （有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。）</li><li><strong>如果需要笔试就提前刷一些笔试题，大部分在线笔试的类型是选择题+编程题，有的还会有简答题。</strong>（平时空闲时间多的可以刷一下笔试题目（牛客网上有很多），但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。）另外，注意抓重点，因为题目太多了，但是有很多题目几乎次次遇到，像这样的题目一定要搞定。</li><li><strong>提前准备技术面试。</strong> 搞清楚自己面试中可能涉及哪些知识点、那些知识点是重点。面试中哪些问题会被经常问到、自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li><li><strong>面试之前做好定向复习。</strong> 也就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</li><li><strong>准备好自己的项目介绍。</strong> 如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：①对项目整体设计的一个感受（面试官可能会让你画系统的架构图；②在这个项目中你负责了什么、做了什么、担任了什么角色；③ 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用；④项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li><li><strong>面试之后记得复盘。</strong> 面试遭遇失败是很正常的事情，所以善于总结自己的失败原因才是最重要的。如果失败，不要灰心；如果通过，切勿狂喜。</li></ol><p><strong>一些还算不错的 Java面试/学习相关的仓库，相信对大家准备面试一定有帮助：</strong><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484817&amp;idx=1&amp;sn=12f0c254a240c40c2ccab8314653216b&amp;chksm=fd9853f0caefdae6d191e6bf085d44ab9c73f165e3323aa0362d830e420ccbfad93aa5901021&amp;token=766994974&amp;lang=zh_CN#rd" target="_blank" rel="noopener">盘点一下Github上开源的Java面试/学习相关的仓库，看完弄懂薪资至少增加10k</a></p><h3 id="Question5-我该自学还是报培训班呢？"><a href="#Question5-我该自学还是报培训班呢？" class="headerlink" title="Question5: 我该自学还是报培训班呢？"></a>Question5: 我该自学还是报培训班呢？</h3><p>　　我本人更加赞同自学（你要知道去了公司可没人手把手教你了，而且几乎所有的公司都对培训班出生的有偏见。为什么有偏见，你学个东西还要去培训班，说明什么，同等水平下，你的自学能力以及自律能力一定是比不上自学的人的）。但是如果，你连每天在寝室坚持学上8个小时以上都坚持不了，或者总是容易半途而废的话，我还是推荐你去培训班。观望身边同学去培训班的，大多是非计算机专业或者是没有自律能力以及自学能力非常差的人。</p><p>　　另外，如果自律能力不行，你也可以通过结伴学习、参加老师的项目等方式来督促自己学习。</p><p>　　总结：去不去培训班主要还是看自己，如果自己能坚持自学就自学，坚持不下来就去培训班。</p><h3 id="Question6-没有项目经历-博客-Github开源项目怎么办？"><a href="#Question6-没有项目经历-博客-Github开源项目怎么办？" class="headerlink" title="Question6: 没有项目经历/博客/Github开源项目怎么办？"></a>Question6: 没有项目经历/博客/Github开源项目怎么办？</h3><p>　　从现在开始做！</p><p>　　网上有很多非常不错的项目视频，你就跟着一步一步做，不光要做，还要改进，改善。另外，如果你的老师有相关 Java 后台项目的话，你也可以主动申请参与进来。</p><p>　　如果有自己的博客，也算是简历上的一个亮点。建议可以在掘金、Segmentfault、CSDN等技术交流社区写博客，当然，你也可以自己搭建一个博客（采用 Hexo+Githu Pages 搭建非常简单）。写一些什么？学习笔记、实战内容、读书笔记等等都可以。</p><p>　　多用 Github，用好 Github，上传自己不错的项目，写好 readme 文档，在其他技术社区做好宣传。相信你也会收获一个不错的开源项目！</p><h3 id="Question7-大厂到底青睐什么样的应届生？"><a href="#Question7-大厂到底青睐什么样的应届生？" class="headerlink" title="Question7: 大厂到底青睐什么样的应届生？"></a>Question7: 大厂到底青睐什么样的应届生？</h3><p>　　从阿里、腾讯等大厂招聘官网对于Java后端方向/后端方向的应届实习生的要求，我们大概可以总结归纳出下面这 4 点能给简历增加很多分数：</p><ul><li>参加过竞赛（含金量超高的是ACM）；</li><li>对数据结构与算法非常熟练；</li><li>参与过实际项目（比如学校网站）；</li><li>参与过某个知名的开源项目或者自己的某个开源项目很不错；</li></ul><p>　　除了我上面说的这三点，在面试Java工程师的时候，下面几点也提升你的个人竞争力：</p><ul><li>熟悉Python、Shell、Perl等脚本语言；</li><li>熟悉 Java 优化，JVM调优；</li><li>熟悉 SOA 模式；</li><li>熟悉自己所用框架的底层知识比如Spring；</li><li>了解分布式一些常见的理论；</li><li>具备高并发开发经验；大数据开发经验等等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　身边的朋友或者公众号的粉丝很多人都向我询问过:“我是双非/三本/专科学校的，我有机会进入大厂吗？”、“非计算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学那些东西？”、“我该如何准备Java面试？”……这些方面的问题。我会根据自己的一点经验对大部分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>匿名内部类</title>
    <link href="https://xxyxt.github.io/2019/01/18/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://xxyxt.github.io/2019/01/18/匿名内部类/</id>
    <published>2019-01-18T06:09:06.859Z</published>
    <updated>2019-01-18T06:25:05.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h3><ul><li>在一个类的内部定义了另外一个类，利用内部类，可以实现私有属性的互相访问</li></ul><h3 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h3><ul><li>没有名字的内部类，必须在抽象类和接口的基础上才可以定义</li></ul><a id="more"></a><h3 id="解决的痛点："><a href="#解决的痛点：" class="headerlink" title="解决的痛点："></a>解决的痛点：</h3><ul><li>如果定义的一个内部类只使用一次便不再使用了，那么就没有必要将其定义为一个具体的类，所以这时便需要一个使用完便不存在的内部类结构，匿名内部类就很好的解决了这个问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Mesage&#123;</span><br><span class="line">public void print();</span><br><span class="line">&#125;</span><br><span class="line">public class testDemo6 &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">fun(new Mesage() &#123;</span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">public static void fun(Mesage msg) &#123;</span><br><span class="line">msg.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用fun()函数时直接实例化借口对象，同时覆写抽象方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内部类：&quot;&gt;&lt;a href=&quot;#内部类：&quot; class=&quot;headerlink&quot; title=&quot;内部类：&quot;&gt;&lt;/a&gt;内部类：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在一个类的内部定义了另外一个类，利用内部类，可以实现私有属性的互相访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;匿名内部类：&quot;&gt;&lt;a href=&quot;#匿名内部类：&quot; class=&quot;headerlink&quot; title=&quot;匿名内部类：&quot;&gt;&lt;/a&gt;匿名内部类：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;没有名字的内部类，必须在抽象类和接口的基础上才可以定义&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://xxyxt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Object类</title>
    <link href="https://xxyxt.github.io/2019/01/17/Object/"/>
    <id>https://xxyxt.github.io/2019/01/17/Object/</id>
    <published>2019-01-17T07:23:02.089Z</published>
    <updated>2019-01-17T08:06:16.330Z</updated>
    
    <content type="html"><![CDATA[<p>Object类是所有类的父类，在定义类时，如果没有明确定义继承哪一种类，那就是继承Object类<br>Object类的三个覆写方法：</p><ul><li>public String toString()             取得对象信息</li><li>public boolean equals(Object obj)    对象比较</li><li>public int hashCode()                取得对象的哈希值</li></ul><a id="more"></a><h2 id="toString-取得对象信息"><a href="#toString-取得对象信息" class="headerlink" title="toString() 取得对象信息"></a>toString() 取得对象信息</h2><p><strong>默认情况下，直接输出一个对象，会输出对象的编码</strong> 但是String类型却不是如此，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Book extends Object&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class testDemo4 &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">Object A=new Book();</span><br><span class="line">Object B=&quot;xxyxt&quot;;</span><br><span class="line">System.out.println(A);</span><br><span class="line">System.out.println(A.toString());</span><br><span class="line">System.out.println(B);</span><br><span class="line">System.out.println(B.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果：</span><br><span class="line">Book@15db9742</span><br><span class="line">Book@15db9742</span><br><span class="line">xxyxt</span><br><span class="line">xxyxt</span><br></pre></td></tr></table></figure></p><p><strong>可以看出：在输出一个对象时，不管调用和toString与否，都会直接输出对象的编码，但是在输出String类的时候，没有输出对象的编码，这是因为，String类中已经覆写了toString方法</strong></p><p>下面覆写一个toString()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class BB&#123;</span><br><span class="line">private double price;</span><br><span class="line">private String name;</span><br><span class="line">public BB(String name,double price) &#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.price=price;</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;书名:&quot; +this.name + &quot;价格：&quot;+this.price; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testDemo5 &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">BB b=new BB(&quot;Java从入门到放弃&quot;,48.9);</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//输出结果：</span><br><span class="line">书名:Java从入门到放弃  价格：48.9</span><br></pre></td></tr></table></figure></p><h2 id="equals-对象比较"><a href="#equals-对象比较" class="headerlink" title="equals() 对象比较"></a>equals() 对象比较</h2><p>默认的equals方法比较的是对象的内存地址数值，但是这并不符合真正的对象比较的需要，通过覆写，可以实现对象的比较的标准方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Book extends Object&#123;</span><br><span class="line">private String name;</span><br><span class="line">private double price;</span><br><span class="line">public Book(String name,double price) &#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.price=price;</span><br><span class="line">&#125;</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">if(this==obj)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if(obj==null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if(!(obj instanceof Book)) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">Book book=(Book) obj;</span><br><span class="line">if(this.name.equals(book.name) &amp;&amp; this.price==book.price)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String toString()&#123;</span><br><span class="line">return &quot;书名：&quot;+ this.name +&quot;价格：&quot;+this.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testDemo4 &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">Book b1=new Book(&quot;入坑&quot;,99.9);</span><br><span class="line">Book b2=new Book(&quot;脱坑&quot;,0.01);</span><br><span class="line">System.out.println(b1.equals(b2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Object类与引用数据类型"><a href="#Object类与引用数据类型" class="headerlink" title="Object类与引用数据类型"></a>Object类与引用数据类型</h2><p>Object是所有类的父类，可以接受所有类的对象，同时夜里可以接收所有引用数据类型，包括数组/接口/类<br>注意：接口不会继承任何类，相应的也不会继承Object类，可以使用Object接收是因为接口是引用数据类型</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object类是所有类的父类，在定义类时，如果没有明确定义继承哪一种类，那就是继承Object类&lt;br&gt;Object类的三个覆写方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public String toString()             取得对象信息&lt;/li&gt;
&lt;li&gt;public boolean equals(Object obj)    对象比较&lt;/li&gt;
&lt;li&gt;public int hashCode()                取得对象的哈希值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://xxyxt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="https://xxyxt.github.io/2019/01/17/%E6%8E%A5%E5%8F%A3/"/>
    <id>https://xxyxt.github.io/2019/01/17/接口/</id>
    <published>2019-01-17T03:35:31.250Z</published>
    <updated>2019-01-17T06:35:42.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h2><p><strong>有抽象方法和全局常量组成的类称之为接口</strong><br><a id="more"></a></p><h3 id="使用原则："><a href="#使用原则：" class="headerlink" title="使用原则："></a>使用原则：</h3><ul><li><p>接口必须有子类，子类可以使用inplements关键字实现多个接口，避免单继承的局限性</p></li><li><p>接口的子类必须覆写接口中全部的抽象方法</p></li><li><p>可以利用子类对象向上转型实现实例化</p></li><li><p>接口可以使用extends关键字同时继承多个父接口，但是不可以继承抽象类</p></li><li><p>一个子类如果既要继承抽象类也要实现接口，应该先继承，后实现接口</p></li></ul><h3 id="接口的限制"><a href="#接口的限制" class="headerlink" title="接口的限制"></a>接口的限制</h3><ul><li><p>接口的限制要比抽象类的限制要少</p></li><li><p>抽象类是单继承原则，但是接口可以多继承</p></li><li><p>从概念上讲，接口由抽象方法和全局常量组成，但是也可以在接口里面定义普通内部类，抽象内部类，内部接口</p></li><li><p>和抽象类类似，如果在接口的内部用static定义了一个内部接口，那么这个接口相当于一个外部接口</p></li></ul><h2 id="接口的实际应用——工厂设计模式-Factory"><a href="#接口的实际应用——工厂设计模式-Factory" class="headerlink" title="接口的实际应用——工厂设计模式(Factory)"></a>接口的实际应用——工厂设计模式(Factory)</h2><p><strong>忽略过程，直接得到结果，更少的修改客户端的代码</strong></p><ul><li><p>如果不采用工厂设计模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Fruit&#123;</span><br><span class="line">public void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements Fruit&#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;吃苹果&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testDemo3 &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">Fruit f=new Apple();</span><br><span class="line">f.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果客户端想要再增加一个吃橘子的类，那么就会修改客户端的代码，采用<strong>工厂设计模式就</strong>可以避免这种直接修改客户端的操作<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">interface Fruit&#123;</span><br><span class="line">public void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Apple implements Fruit&#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;eat apple&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Orange implements Fruit&#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;eat orange&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">public static Fruit getInstance(String className) &#123;</span><br><span class="line">if(&quot;apple&quot;.equals(className)) &#123;</span><br><span class="line">return new Apple();</span><br><span class="line">&#125;</span><br><span class="line">if(&quot;orange&quot;.equals(className))&#123;</span><br><span class="line">return new Orange();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class testDemo3 &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">Fruit f=Factory.getInstance(&quot;orange&quot;);</span><br><span class="line">f.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口的实际应用——代理设计模式-Proxy"><a href="#接口的实际应用——代理设计模式-Proxy" class="headerlink" title="接口的实际应用——代理设计模式(Proxy)"></a>接口的实际应用——代理设计模式(Proxy)</h2><h3 id="代理设计模式的实现——以代理上网为例"><a href="#代理设计模式的实现——以代理上网为例" class="headerlink" title="代理设计模式的实现——以代理上网为例"></a>代理设计模式的实现——以代理上网为例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface Network&#123;                   //定义接口</span><br><span class="line">public void browse();            //定义浏览抽象方法</span><br><span class="line">&#125;</span><br><span class="line">class Real implements Network&#123;       //真实上网操作</span><br><span class="line">public void browse() &#123;           //覆写抽象方法</span><br><span class="line">System.out.println(&quot;上网浏览&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Proxy implements Network&#123;      //代理上网</span><br><span class="line">private Network network;</span><br><span class="line">public Proxy(Network network) &#123;  //代理的真实操作</span><br><span class="line">this.network=network;</span><br><span class="line">&#125;</span><br><span class="line">public void check() &#123;             //具体上网相关的操作</span><br><span class="line">System.out.println(&quot;检查用户合法性&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void browse() &#123;</span><br><span class="line">this.check();                  //调用与上网相关的具体操作</span><br><span class="line">this.network.browse();         //调用真实上网操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class tesnDemo2&#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">Network net=null;                //定义接口对象</span><br><span class="line">net=new Proxy(new Real());       //实例化代理，同时传入代理的真实操作</span><br><span class="line">net.browse();                   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于接口&quot;&gt;&lt;a href=&quot;#关于接口&quot; class=&quot;headerlink&quot; title=&quot;关于接口&quot;&gt;&lt;/a&gt;关于接口&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;有抽象方法和全局常量组成的类称之为接口&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://xxyxt.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>翻转连续最长子序列</title>
    <link href="https://xxyxt.github.io/2019/01/16/%E7%BF%BB%E8%BD%AC%E8%BF%9E%E7%BB%AD%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://xxyxt.github.io/2019/01/16/翻转连续最长子序列/</id>
    <published>2019-01-16T11:56:44.946Z</published>
    <updated>2019-01-16T12:11:50.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>有一个仅包含a和b两种字符的字符串s，长度为n，每次操作可以把一个字符做一次转换（把一个a设置为b，或者把一个b置成a)；但是操作的次数有上限m，问在有限的操作数范围内，能够得到最大连续的相同字符的子串的长度是多少。</li></ul><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><ul><li>第一行两个整数 n , m (1&lt;=m&lt;=n&lt;=50000)，第二行为长度为n且只包含a和b的字符串s。</li></ul><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><ul><li>输出在操作次数不超过 m 的情况下，能够得到的 最大连续 全a子串或全b子串的长度。<a id="more"></a></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 1</span><br><span class="line">aabaabaa</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="分析-以翻转a为例"><a href="#分析-以翻转a为例" class="headerlink" title="分析(以翻转a为例)"></a>分析(以翻转a为例)</h2><ul><li>翻转的操作次数为m，如果可以找出包含m个a的最长连续子串，然后将m个a翻转，即为本题的答案。</li><li>将a的下标组成新的数组array,则包含m个a连续序列的长度为 array[i+m]-array[i-1]-1;</li><li>如果这m个a中包含序列中的第一个或者最后一个a，那么，连续序列的长度为 array[i+m]-array[i-1];</li></ul><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=50040;</span><br><span class="line">void longstr(string str,int k)  //输出最长连续序列函数 </span><br><span class="line">&#123;</span><br><span class="line">    int len=str.length();</span><br><span class="line">    int arraya[maxn]=&#123;0&#125;;      //字符串中所有元素&apos;a&apos;的下标组成的数列 </span><br><span class="line">    int arrayb[maxn]=&#123;0&#125;;      //字符串中所有元素&apos;b&apos;的下标组成的数列 </span><br><span class="line">    int J=1;                   //计数符 </span><br><span class="line">    int K=1;</span><br><span class="line">    int maxa=0;                //记录最大长度 </span><br><span class="line">    int maxb=0;</span><br><span class="line">    for(int i=0;i&lt;len;i++)     //遍历字符串，生成目标数组 </span><br><span class="line">    &#123;</span><br><span class="line">        if(str[i]==&apos;a&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            arraya[J++]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(str[i]==&apos;b&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">             arrayb[K++]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">    arraya[J]=len;           //添加首末元素 </span><br><span class="line">    arrayb[K]=len;</span><br><span class="line">    arraya[0]=1;</span><br><span class="line">    arrayb[0]=1;</span><br><span class="line">    int temp1,temp2;         //记录每一个遍历的连续字符串长度 </span><br><span class="line">    for(int i=1;i&lt;=J-k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==1 || i==J-k)     //如果要反转的字符在第一个或者最后一个 </span><br><span class="line">        &#123;</span><br><span class="line">            temp1=arraya[i+k]-arraya[i-1];  //不需要减去1 </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            temp1=arraya[i+k]-arraya[i-1]-1;  //否则需要减去1 </span><br><span class="line">        &#125;</span><br><span class="line">        if(temp1&gt;maxa)</span><br><span class="line">        &#123;</span><br><span class="line">            maxa=temp1;           //将最大值保存 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=K-k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==1 || i==K-k)</span><br><span class="line">        &#123;</span><br><span class="line">             temp2=arrayb[i+k]-arrayb[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">             temp2=arrayb[i+k]-arrayb[i-1]-1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(temp2&gt;maxb)</span><br><span class="line">        &#123;</span><br><span class="line">            maxb=temp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int a=(maxa&gt;maxb)?maxa:maxb;   //找出翻转a和b中最长的序列 </span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        int len=str.length();</span><br><span class="line">        longstr(str,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;有一个仅包含a和b两种字符的字符串s，长度为n，每次操作可以把一个字符做一次转换（把一个a设置为b，或者把一个b置成a)；但是操作的次数有上限m，问在有限的操作数范围内，能够得到最大连续的相同字符的子串的长度是多少。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class=&quot;headerlink&quot; title=&quot;输入描述&quot;&gt;&lt;/a&gt;输入描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;第一行两个整数 n , m (1&amp;lt;=m&amp;lt;=n&amp;lt;=50000)，第二行为长度为n且只包含a和b的字符串s。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;输出在操作次数不超过 m 的情况下，能够得到的 最大连续 全a子串或全b子串的长度。
    
    </summary>
    
      <category term="刷题笔记" scheme="https://xxyxt.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://xxyxt.github.io/tags/C-C/"/>
    
      <category term="2018笔试题" scheme="https://xxyxt.github.io/tags/2018%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>多态性</title>
    <link href="https://xxyxt.github.io/2019/01/15/%E5%A4%9A%E6%80%81%E6%80%A7/"/>
    <id>https://xxyxt.github.io/2019/01/15/多态性/</id>
    <published>2019-01-15T12:35:19.857Z</published>
    <updated>2019-01-16T03:09:19.014Z</updated>
    
    <content type="html"><![CDATA[<p>多态性主要在两个方面：</p><ol><li><p>方法多态</p><ul><li>覆写</li><li>重载</li></ul></li><li><p>对象多态</p><ul><li>对象的多态性为父子类对象的转换</li><li>向上转型：父类 父类对象 = 子类实例</li><li>向下转型：子类 子类对象 = (子类) 父类实例</li><li>必须发生向上转型之后才可以发生向下转型</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多态性主要在两个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;方法多态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;覆写&lt;/li&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象多态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象的多态性为父子类对象的转换&lt;/li&gt;
&lt;li&gt;向上转型：父类 父
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>子类的覆写</title>
    <link href="https://xxyxt.github.io/2019/01/15/%E8%A6%86%E5%86%99/"/>
    <id>https://xxyxt.github.io/2019/01/15/覆写/</id>
    <published>2019-01-15T11:46:27.553Z</published>
    <updated>2019-01-15T12:21:20.917Z</updated>
    
    <content type="html"><![CDATA[<p>子类可以继承父类的属性和方法，也可以在父类的基础上进行拓展，也可以根据父类已有的方法名进行再次定义，我们可以称之为覆写</p><h2 id="方法的覆写"><a href="#方法的覆写" class="headerlink" title="方法的覆写"></a>方法的覆写</h2><a id="more"></a><ul><li><p>子类定义的方法名称、返回值类型、参数类型及个数与父类完全相同，称之为方法的覆写</p></li><li><p>被子类覆写的方法，不能拥有比父类更严格的访问权限</p></li><li><p>访问权限从宽到严的顺序为：public &gt; default &gt; private</p></li><li><p>父类方法的访问权限如果是private，则不能够被覆写，可以通过super.fangfa()来进行调用</p></li></ul><p><strong>方法重载(overloading)和覆写(overrid)的区别：</strong></p><ul><li><p>发生范围：重载发生在一个类里面，覆写发生在继承里面</p></li><li><p>权限：重载没有权限限制，继承的子类的覆写不能拥有比弗雷更加严格的访问限制</p></li><li><p>定义：重载参数类型及个数不同，覆写则都相同</p></li></ul><h2 id="属性的覆写"><a href="#属性的覆写" class="headerlink" title="属性的覆写"></a>属性的覆写</h2><ul><li><p>属性的覆写就是属性的覆写</p></li><li><p>实际开发中类的属性是被封装的，所以属性的覆写意义不大</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;子类可以继承父类的属性和方法，也可以在父类的基础上进行拓展，也可以根据父类已有的方法名进行再次定义，我们可以称之为覆写&lt;/p&gt;
&lt;h2 id=&quot;方法的覆写&quot;&gt;&lt;a href=&quot;#方法的覆写&quot; class=&quot;headerlink&quot; title=&quot;方法的覆写&quot;&gt;&lt;/a&gt;方法的覆写&lt;/h2&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java关键字</title>
    <link href="https://xxyxt.github.io/2019/01/15/this-static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://xxyxt.github.io/2019/01/15/this-static关键字/</id>
    <published>2019-01-15T02:24:03.984Z</published>
    <updated>2019-01-16T01:54:47.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this-关键字的用法"><a href="#this-关键字的用法" class="headerlink" title="this 关键字的用法"></a>this 关键字的用法</h2><p>Java开发离不开关键字this,this有三类用法：</p><h3 id="调用本类属性"><a href="#调用本类属性" class="headerlink" title="调用本类属性"></a>调用本类属性</h3><p>为了避免类的<strong>属性名称</strong>和<strong>方法参数名称</strong>的重复，需要用<strong>this.</strong>属性的形式，来明确指明调用的是属性而不是参数<br>注：为了避免不必要的麻烦，在访问类的属性时，不管名称重复与否，都加上this关键字</p><a id="more"></a><h3 id="调用本类方法"><a href="#调用本类方法" class="headerlink" title="调用本类方法"></a>调用本类方法</h3><p>类中的方法主要有两种：普通和构造方法。所以调用本类方法也有两种形式：</p><ul><li><p>普通方法：this.方法()</p></li><li><p>构造方法：this()</p><p>注：用this(),可以很好解决构造方法中的代码重复问题</p></li></ul><h3 id="表示当前对象"><a href="#表示当前对象" class="headerlink" title="表示当前对象"></a>表示当前对象</h3><ul><li>表示当前调用类中方法的实例化对象</li></ul><h2 id="static-关键字的用法"><a href="#static-关键字的用法" class="headerlink" title="static 关键字的用法"></a>static 关键字的用法</h2><h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><ul><li>在声明属性前加上static关键字，表示公共属性</li><li><p>公共属性，任何一个对象修改了此属性的内容都会影响其他的对象。好比一个人有多个名字，小张、狗蛋、二狗子，如果小张的腿摔断了，那么狗蛋和二狗子的腿也会摔断，因为他们是同一个人</p></li><li><p>static定义的属性保存在<strong>全局数据区</strong></p></li><li><p>static定义的属性可以由类直接调用，而非static属性必须在实例化对象之后，由对象调用</p></li><li><p>定义共享属性的时候才会使用static，一般情况都是使用非属性</p></li></ul><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>和定义属性一样，使用static定义普通方法时，没有经过实例化产生对象可以直接由类名直接调用</p><p>注意：</p><ul><li>static方法不能直接访问非static方法或属性</li><li>非static方法可以直接调用或访问static方法</li></ul><p>原因：</p><ul><li>非static结构在实例化对象之后才会分配堆空间，才可以使用</li><li>static不受实例化对象的控制</li></ul><h2 id="public-static-void-main-String-args"><a href="#public-static-void-main-String-args" class="headerlink" title="public static void main(String args[])"></a>public static void main(String args[])</h2><p>刚刚开始接触java时，感觉这个一大串好长，每个部分究竟各自代表什么意义，不写其中的任何一项可不可以</p><ul><li>public：表示此方法对任何操作都是可见的</li><li>static：此类方法由类名直接调用</li><li>void: 表示返回值为空</li><li>main: 规定的名称</li><li>String args[]: 程序运行时传递的参数，java类名 参数 参数 参数</li></ul><h2 id="final关键字的用法"><a href="#final关键字的用法" class="headerlink" title="final关键字的用法"></a>final关键字的用法</h2><ul><li><p>使用final定义的类不能再有子类，String类就是final定义的类</p></li><li><p>final定义的方法不能够被覆写 <figure class="highlight plain"><figcaption><span>final void fun()```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- final定义的变量变为常量 类似于C++里面的 const</span><br><span class="line"></span><br><span class="line">- 全局常量：即用public static final 3个关键字定义的常量 ``` public static final String xxy=&quot;LOVE&quot;</span><br></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this-关键字的用法&quot;&gt;&lt;a href=&quot;#this-关键字的用法&quot; class=&quot;headerlink&quot; title=&quot;this 关键字的用法&quot;&gt;&lt;/a&gt;this 关键字的用法&lt;/h2&gt;&lt;p&gt;Java开发离不开关键字this,this有三类用法：&lt;/p&gt;
&lt;h3 id=&quot;调用本类属性&quot;&gt;&lt;a href=&quot;#调用本类属性&quot; class=&quot;headerlink&quot; title=&quot;调用本类属性&quot;&gt;&lt;/a&gt;调用本类属性&lt;/h3&gt;&lt;p&gt;为了避免类的&lt;strong&gt;属性名称&lt;/strong&gt;和&lt;strong&gt;方法参数名称&lt;/strong&gt;的重复，需要用&lt;strong&gt;this.&lt;/strong&gt;属性的形式，来明确指明调用的是属性而不是参数&lt;br&gt;注：为了避免不必要的麻烦，在访问类的属性时，不管名称重复与否，都加上this关键字&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类的继承性</title>
    <link href="https://xxyxt.github.io/2019/01/15/Java%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7/"/>
    <id>https://xxyxt.github.io/2019/01/15/Java类的继承性/</id>
    <published>2019-01-15T01:56:27.641Z</published>
    <updated>2019-01-15T06:58:48.657Z</updated>
    
    <content type="html"><![CDATA[<p>继承性是面向对象的一个主要特征，主要解决了代码的重复利用的问题，利用继承性可以从已有的类中派生新的子类，也可以利用子类扩展出更多的操作<br><a id="more"></a><br>语法实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>继承性的限制：<br>限制一：不可以多重继承，可以多层继承</p><ul><li>class A extends C,D    错误</li><li>class A{}    class B extends A{}    class C extends B{}</li><li>继承的层次不要过多<br>限制二：子类继承父类，会继承父类的全部操作，但是对于对于私有操作属于隐式继承，非私有操作属于显示继承<br>限制三：子类对象构造前，一定会默认调用<strong>父类的构造</strong>，父类对象先实例化，子类对象后实例化，所以子类对象相当于隐含了super()的 语句调用</li><li>注：父类中提供无参构造时，是否编写super()没有区别，如果没有无参构造，则必须明确使用super()调用父类指定的构造方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承性是面向对象的一个主要特征，主要解决了代码的重复利用的问题，利用继承性可以从已有的类中派生新的子类，也可以利用子类扩展出更多的操作&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://xxyxt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="https://xxyxt.github.io/2019/01/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <id>https://xxyxt.github.io/2019/01/14/二叉树的几种遍历方法/</id>
    <published>2019-01-14T12:02:20.000Z</published>
    <updated>2019-01-14T12:13:12.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong>二叉树的遍历指按照一定的顺序访问二叉树的所有节点</strong></p><p>访问方法一共四种：先序遍历，中序遍历，后续遍历，层序遍历<br>前三种遍历一般用DFS方法，层序遍历需要BFS方法<br>先、中、后序遍历，都是指的根节点的访问顺序<br>先序代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void preorder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">if(root==NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;root-&gt;data;</span><br><span class="line">preorder(root-&gt;left);</span><br><span class="line">preorder(root-&gt;right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>中序代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void inorder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">if(root==NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inorder(root-&gt;left);</span><br><span class="line">cout&lt;&lt;root-&gt;data;</span><br><span class="line">inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后续代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void postorder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">if(root==NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">postorder(root-&gt;left);</span><br><span class="line">postorder(root-&gt;right);</span><br><span class="line">cout&lt;&lt;root-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>层序遍历，是按照层次的顺序，访问节点，采用广度优先的访问方法结合队列实现操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void layerorder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">node* now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">cout&lt;&lt;now-&gt;data;</span><br><span class="line">if(now-&gt;left!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">q.push(now-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">if(now-&gt;right!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">q.push(now-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;二叉树的遍历指按照一定的顺序访问二叉树的所有节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问方法一共四种：先序遍历，中序遍历，后续遍历，层序遍历&lt;br&gt;前三种遍历一般用DFS方法，层序遍历需要BFS方法&lt;br&gt;先、中、后序遍历，都是指的根节点的访问顺序&lt;br&gt;先序代码：&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="https://xxyxt.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://xxyxt.github.io/2019/01/12/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://xxyxt.github.io/2019/01/12/最长回文子串/</id>
    <published>2019-01-12T06:57:24.000Z</published>
    <updated>2019-01-12T07:01:14.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>给出一个字符串S，求S的最长回文子串的长度。</p><p>例：字符串“ASDFGHGFDSB”的最长回文子串为“SDFGHGFDS”，长度为9。</p><p>显然暴力解法的不仅复杂度较大，而且超级繁琐，采用动态规划可以更好的解决这类问题<br><a id="more"></a></p><p>令dp[i][j]表示S[i]至S[j]所表示的子串是否回文，是则为1，不是则为0.这样可以根据S[i]和S[j]是否相等分为两种情况：</p><ol><li>如果S[i]==S[j]，那么只要S[i+1]至S[j-1]是回文子串，那么S[i]至S[j]也是回文子串；如果S[i+1]至S[j-1]不是回文子串，那么S[i]至S[j]也不是回文子串；</li><li>如果S[i]!=S[j]，那么S[i]至S[j]一定不是回文子串<br>边界：dp[i][i]=1, dp[i][i+1]=(S[i]==S[i+1])?1:0</li></ol><p><strong>注意：如果按照i和j从小到大的顺序来枚举子串的端点，然后更新dp[i][j]，这样会无法保证dp[i+1][j-1]已经得到计算，从而无法进行状态转移</strong>。</p><p>因为边界的子串长度为1和2，所以可以考虑按照子串的长度和初始位置进行枚举，即第一遍将子串长度为3的dp值全部求出来，第二遍计算长度为4的子串可以通过计算出的长度为3的子串的dp值进行计算。这样问题就可以得到解决</p><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">const int maxn = 10010;</span><br><span class="line">char S[maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">gets(S);</span><br><span class="line">int len = strlen(S);</span><br><span class="line">int ans = 1; //初始化最长回文子串长度为1 </span><br><span class="line">memset(dp, 0, sizeof(dp));</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">if (i &lt; len - 1)</span><br><span class="line">&#123;</span><br><span class="line">if (S[i] == S[i + 1])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][i + 1] = 1;</span><br><span class="line">ans = 2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//状态转移方程</span><br><span class="line">for (int L = 3; L &lt;= len; L++)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i + L - 1 &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">int j = i + L - 1;</span><br><span class="line">if (S[i] == S[j] &amp;&amp; dp[i + 1][j - 1] == 1)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = 1;</span><br><span class="line">ans = L;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><p><a href="https://www.nowcoder.com/practice/12e081cd10ee4794a2bd70c7d68f5507?tpId=37&amp;tqId=21308&amp;tPage=5&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/12e081cd10ee4794a2bd70c7d68f5507?tpId=37&amp;tqId=21308&amp;tPage=5&amp;rp=&amp;ru=%2Fta%2Fhuawei&amp;qru=%2Fta%2Fhuawei%2Fquestion-ranking</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;给出一个字符串S，求S的最长回文子串的长度。&lt;/p&gt;
&lt;p&gt;例：字符串“ASDFGHGFDSB”的最长回文子串为“SDFGHGFDS”，长度为9。&lt;/p&gt;
&lt;p&gt;显然暴力解法的不仅复杂度较大，而且超级繁琐，采用动态规划可以更好的解决这类问题&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="https://xxyxt.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="动态规划" scheme="https://xxyxt.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>01背包问题</title>
    <link href="https://xxyxt.github.io/2019/01/11/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://xxyxt.github.io/2019/01/11/01背包问题/</id>
    <published>2019-01-11T05:34:52.000Z</published>
    <updated>2019-01-11T12:26:57.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>问题：有n件物品，每件物品重量为w[ i ]，价值为c[ i ]。现有一个容量为V的背包，问如何选取物品放入背包，使背包总价值最大，其中每个物品只有一件。<br><a id="more"></a><br>样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=5 V=8</span><br><span class="line">3 5 1 2 2 // w[ i ]</span><br><span class="line">4 5 2 1 3 / / c[ i ]</span><br></pre></td></tr></table></figure></p><p>显然，对于每件物品有两种选择，暴力解法复杂度为O($2^n$)<br>用dp[i][v]表示第i件物品放入容量为v的背包，则dp[i][v]的值求解有两种选择：</p><ol><li>不放入第i件物品，那么问题转化为前i-1件物品放入容量为v的背包获得的最大价值，dp[ i-1 ][ v ]</li><li>放入第i件物品，那么问题转化为前i-1件物品放入容量为v-w[i]的背包获得的最大价值<br>dp[ i-1][ v-w[ i ] ]+c[ i ]</li></ol><p><strong>公式为</strong>：dp[ i ][ v ] = max{ dp[ i-1 ][ v ], dp[ i-1 ][ v - w[ i ] ] + c[ i ] }<br>第i件物品的状态，只与第i-1件物品的状态有关，所以可以通过边界dp[0][v]=0(0&lt;=v&lt;=V)，递推得到整个数组</p><h4 id="二维数组实现代码："><a href="#二维数组实现代码：" class="headerlink" title="二维数组实现代码："></a>二维数组实现代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int v=w[i];w[i]&lt;V;v++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][v]=max(dp[i-1][v],dp[i-1][v-w[i]]+c[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样计算得出的dp[ n ][ V ]的值即为最大值</strong><br>其实上面的代码还可以在空间复杂度上进行优化，可以看出，在计算dp[i+1][v]的值时，dp[i-1][v]的值没有用到，因此不妨直接用一维数组来代替二维数组，枚举方向从1到n,v从V到0，状态转移方程变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[ v ] = max(dp[ v ],dp[ v-w[ i ]]+c[ i ])</span><br></pre></td></tr></table></figure></p><h4 id="一维数组实现代码："><a href="#一维数组实现代码：" class="headerlink" title="一维数组实现代码："></a>一维数组实现代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1;i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int v = V; v&gt;=w [ i ]; v--)</span><br><span class="line">&#123;</span><br><span class="line">dp[ v ] = max(dp[ v ], dp[ v - w[ i ]] + c[ i ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样得到的最大值，需要在数组dp里面找出最大值，不是dp[ V ]</strong></p><h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><p><a href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&amp;tqId=21239&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&amp;tqId=21239&amp;tPage=1&amp;rp=&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;01背包问题&quot;&gt;&lt;a href=&quot;#01背包问题&quot; class=&quot;headerlink&quot; title=&quot;01背包问题&quot;&gt;&lt;/a&gt;01背包问题&lt;/h2&gt;&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;问题：有n件物品，每件物品重量为w[ i ]，价值为c[ i ]。现有一个容量为V的背包，问如何选取物品放入背包，使背包总价值最大，其中每个物品只有一件。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="动态规划" scheme="https://xxyxt.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>安装pyinstaller报错</title>
    <link href="https://xxyxt.github.io/2019/01/11/%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/"/>
    <id>https://xxyxt.github.io/2019/01/11/安装报错/</id>
    <published>2019-01-11T02:28:47.000Z</published>
    <updated>2019-01-11T02:35:45.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装pyinstaller报错：Python-library-not-in-binary-dependencies"><a href="#安装pyinstaller报错：Python-library-not-in-binary-dependencies" class="headerlink" title="安装pyinstaller报错：Python library not in binary dependencies"></a>安装pyinstaller报错：Python library not in binary dependencies</h2><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>Centos7.0<br>Python3.6<br><a id="more"></a></p><h2 id="pyinstaller安装"><a href="#pyinstaller安装" class="headerlink" title="pyinstaller安装"></a>pyinstaller安装</h2><p>照着网上的一些教程安装了pyinstaller</p><pre><code>pip3 installer pyinstaller</code></pre><p>   将pyinstaller的路径添加到环境变量</p><pre><code>export PATH=$PATH:/usr/local/python3/lib/python3.6/site-packages</code></pre><p>修改配置文件，将上一条命令写入  /etc/profile 文件</p><pre><code>vi /etc/profile</code></pre><p>然后装完之后开始使用，试着打包自己刚刚写的一个py文件</p><pre><code>pyinstaller ex14.py</code></pre><p>然后就开始报错</p><pre><code>[root@VM_0_13_centos python_ex]# pyinstaller -F ex41.pyOSError: Python library not found: libpython3.6mu.so.1.0, libpython3.6.so.1.0, libpython3.6m.so.1.0This would mean your Python installation doesn&apos;t come with proper library files.This usually happens by missing development package, or unsuitable build parameters of Python installation.On Debian/Ubuntu, you would need to install Python development packages  * apt-get install python3-dev  * apt-get install python-dev  *  If you&apos;re building Python by yourself, please rebuild your Python with `--enable-shared` (or, `--enable-framework` on Darwin)</code></pre><p>解决办法<br>1打开  /etc/ld.so.conf 写入<br>/usr/local/lib64<br>/usr/local/lib</p><pre><code>vi /etc/ld.so.conf</code></pre><p>2</p><pre><code>ldconfig</code></pre><p>3</p><pre><code>pyinstaller ex14.py</code></pre><p>这样就解决问题了<br><img src="https://img-blog.csdn.net/20180927004219612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyMzkwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装pyinstaller报错：Python-library-not-in-binary-dependencies&quot;&gt;&lt;a href=&quot;#安装pyinstaller报错：Python-library-not-in-binary-dependencies&quot; class=&quot;headerlink&quot; title=&quot;安装pyinstaller报错：Python library not in binary dependencies&quot;&gt;&lt;/a&gt;安装pyinstaller报错：Python library not in binary dependencies&lt;/h2&gt;&lt;h2 id=&quot;运行环境&quot;&gt;&lt;a href=&quot;#运行环境&quot; class=&quot;headerlink&quot; title=&quot;运行环境&quot;&gt;&lt;/a&gt;运行环境&lt;/h2&gt;&lt;p&gt;Centos7.0&lt;br&gt;Python3.6&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://xxyxt.github.io/categories/python/"/>
    
    
      <category term="经验" scheme="https://xxyxt.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>使用Github+Hexo搭建自己的博客</title>
    <link href="https://xxyxt.github.io/2019/01/08/%E4%BD%BF%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://xxyxt.github.io/2019/01/08/使用Github-Hexo搭建自己的博客/</id>
    <published>2019-01-08T12:09:04.420Z</published>
    <updated>2019-01-12T07:00:52.542Z</updated>
    
    <content type="html"><![CDATA[<p>我的电脑是win10    64位的</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a><strong>前期准备</strong></h2><ul><li>去官网下载Node.js文件，下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>安装完成后，windows运行窗口输入：<code>node -v</code> 会出现版本信息，则安装成功</li></ul><a id="more"></a><ul><li>去官网下载Git安装包，下载地址：<a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">https://www.git-scm.com/download/win</a><br>按照默认的安装方式，一直点next即可安装成功，默认是安装在C盘，记得修改安装盘符<br>安装完成后，windows运行窗口输入：<code>git --version</code> 会出现版本信息，则安装成功</li></ul><p><strong>注意：安装成功之后，如果输入上述命令，没有出现对应的信息，则将安装路径添加到用户环境变量（我的是F:\Git\cmd)，再次打开运行窗口输入命令即可。</strong></p><h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><p>Github Pages 其实本身就是 Github 提供的博客服务。 我们在 Github 中创建一个特定格式的 Repository，Github Pages 就会将里面的信息生成一个网页，展示出来。</p><p><strong>操作如下：</strong></p><ol><li><p>注册 Github 账号，然后在 Github 中创建一个以 .github.io 结尾的 Repository。</p><ul><li style="list-style: none"><input type="checkbox"> Repository name: xxyxt.github.io</li><li style="list-style: none"><input type="checkbox"> 勾选 Initialize this repository with a README</li><li style="list-style: none"><input type="checkbox"> Create repository</li></ul></li><li>简单地编辑一下 README.md 这个文档。 比如添加：this is a test blog. 保存(Commit changes)。</li><li>打开网页：xxyxt.github.io 这里就可以看到 README.md 里的内容了。</li></ol><p>这个生成好的 Repository 就是用来存放博客内容的地方，也只有这个仓库里的内容，才会被 xxyxt.github.io 这个网页显示出来。</p><h2 id="hexo-博客框架"><a href="#hexo-博客框架" class="headerlink" title="hexo 博客框架"></a>hexo 博客框架</h2><ul><li><strong>安装hexo</strong></li></ul><p>在准备工作中，我们已经安装了<strong>Node.js</strong>和<strong>Git</strong>，接下来直接安装 hexo 即可</p><ul><li style="list-style: none"><input type="checkbox"> 在windows运行命令窗口中输入 <code>nmp install -g hexo-cli</code></li></ul><ul><li style="list-style: none"><input type="checkbox"> 安装完成后，输入 <code>hexo -v</code></li></ul><p>得到版本信息，即安装成功</p><ul><li><p><strong>设置全局配置 user.name 和 user.email</strong><br>鼠标右击，单击Git bash here，打开命令窗口，输入</p><p>  <code>git config –-global user.name “张三”</code>  //(“”的账号是刚才Github里面自己注册的账号)<br>  <code>git config –-global user.email “1234567@qq.com”</code> //(“”的邮箱是你自己注册的邮箱)</p></li><li><p><strong>生成SSH密钥设置到Github</strong><br><code>cd ~/.ssh</code><br><code>ssh-keygen -t rsa -C “username”</code>  //这里的username为计算机名<br>如果  <code>cd ~/.ssh</code> 显示No such file，可以输入命令 <code>mkdir ~/.ssh</code> 创建一个文件夹，然后执行相应的操作即可，出现下图，则设置成功<img src="https://img-blog.csdnimg.cn/20190108185113300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyMzkwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>设置ssh key到GitHub 默认生成ssh key在C:\Users\username.ssh文件夹中，用记事本打开 id_rsa.pub文件，复制 i文件内容到 github-&gt;settings-&gt;SSH and GPG key-&gt;new ssh-&gt;key </p></li><li><p><strong>ssh设置是否成功测试</strong></p><p>  输入命令 <code>ssh -T git@github.com</code> </p></li><li><p><strong>创建本地博客</strong></p></li></ul><ul><li style="list-style: none"><input type="checkbox"> 在D盘下创建文件夹 test</li></ul><ul><li style="list-style: none"><input type="checkbox"> 鼠标右键 test，选择 Git Bash Here</li></ul><ul><li style="list-style: none"><input type="checkbox"> Git Bash 打开之后，所在的位置就是 test 这个文件夹的位置。（/F/test）</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo init</code> 将 test文件夹初始化成一个博客文件夹。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>npm install</code> 安装依赖包。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo g</code> 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo s</code> 将生成的网页放在了本地服务器（server）。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 浏览器里输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 。 就可以看到刚才的成果了。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 回到 Git Bash，按 Ctrl+C 结束。<br>此时再看 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就是无法访问了。</li></ul><p>问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号</p><ul><li><strong>发布一篇博客</strong></li></ul><p>如果你按照前面的教程走下来，没有退出刚刚的Git Bash界面，当前路径是刚刚初始化的test路径，输入 <code>hexo new &quot;My First Post&quot;</code></p><ul><li style="list-style: none"><input type="checkbox"> 在<code>F:\test\source_posts</code>路径下，会有一个 My-First-Post.md 的文件。 编辑这个文件，然后保存。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 回到 Git Bash，输入 <code>hexo g</code> 生成博客</li></ul><ul><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo s</code> 开启服务</li></ul><ul><li style="list-style: none"><input type="checkbox"> 前往 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看成果。</li></ul><ul><li style="list-style: none"><input type="checkbox"> 回到 Git Bash，按 Ctrl+C 结束。如果不结束的话，接口会一直被占用。</li></ul><ul><li><strong>将本地Hexo博客部署在Github上</strong></li></ul><p>前面两个部分，我们已经有了本地博客，和一个能托管这些资料的线上仓库。只要把本地博客部署（deploy）在我们的 Github 对应的 Repository 就可以了。</p><h6 id="操作如下："><a href="#操作如下：" class="headerlink" title="操作如下："></a>操作如下：</h6><ol><li><p>获取 Github 对应的 Repository 的链接。</p><ul><li style="list-style: none"><input type="checkbox"> 登陆 Github，进入到 xxyxt.github.io    </li><li style="list-style: none"><input type="checkbox"> 点击 Clone or download    </li><li style="list-style: none"><input type="checkbox"> 复制 URL 待用，我的是 <a href="https://github.com/xxyxt/xxyxt.github.io.git" target="_blank" rel="noopener">https://github.com/xxyxt/xxyxt.github.io.git</a></li></ul></li></ol><ol start="2"><li><p>修改博客的配置文件</p><ul><li style="list-style: none"><input type="checkbox"> 打开配置文件 /F/test/_config.yml （使用 bash 里的 vi 或者 notepad）</li><li style="list-style: none"><input type="checkbox"> 找到 #Deployment，填入以下内容：<br>deploy:<br>type: git<br>repository: <a href="https://github.com/xxyxt/xxyxt.github.io.git" target="_blank" rel="noopener">https://github.com/xxyxt/xxyxt.github.io.git</a><br>branch: master</li></ul></li></ol><ol start="3"><li>部署</li></ol><ul><li style="list-style: none"><input type="checkbox"> 回到 Git Bash 输入 <code>npm install hexo-deployer-git --save</code> 安装 hexo-deployer-git 此步骤只需要做一次。</li><li style="list-style: none"><input type="checkbox"> 输入 <code>hexo d</code></li><li style="list-style: none"><input type="checkbox"> 得到 INF Deploy done: git 即为部署成功</li></ul><p>之前我们创建的 ReadMe.md 会被自动覆盖掉。</p><ol start="4"><li>查看成果</li></ol><p>前往 xxyxt.github.io 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的电脑是win10    64位的&lt;/p&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;&lt;strong&gt;前期准备&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;去官网下载Node.js文件，下载地址：&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;br&gt;安装完成后，windows运行窗口输入：&lt;code&gt;node -v&lt;/code&gt; 会出现版本信息，则安装成功&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://xxyxt.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="博客" scheme="https://xxyxt.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
